import * as types from '../types';

import {StoreWrapper} from '../core/reduxa';
import {Server} from '../core/server';
import {MapManager} from '../map/manager';
import {DefaultTool} from './default-tool';
import {RootController} from './root-controller';

import * as api from '../core/gws-api';
import * as tools from '../tools';

export class Application implements types.IApplication {
    domNode: HTMLDivElement;
    map: MapManager;
    overviewMap: MapManager;
    options: types.Dict;
    project: api.ProjectProps;
    server: Server;
    store: StoreWrapper;
    tags: types.Dict;
    urlParams: types.Dict;

    protected controllers: { [key: string]: types.IController } = {};
    protected cssBreakpoints: Array<[string, number]>;
    protected initialState: types.Dict = {};
    protected labels = {};
    protected locale = '';
    protected tempTools = [];
    protected tools: types.Dict = {};
    protected uid = 0;
    protected requestingUrls: Array<string> = [];
    protected isLoaded = false;

    static async create(options): Promise<Application> {
        let app = new this(options);
        return await app.init();
    }

    get rootController() {
        return this.controllers['root'];
    }

    constructor(options) {
        console.log(options)
        this.options = options;

        this.store = new StoreWrapper({});

        this.tags = this.options.tags;
        this.tags['DefaultTool'] = DefaultTool;

        this.labels = this.options.labels;
        this.locale = this.options.locale || 'en_CA';

        let url = this.options.serverUrl || '/_';
        this.server = new Server(this, url);

        this.server.whenRequestStarted = (cmd, params) => this.requestStarted('COMMAND:' + cmd);
        this.server.whenRequestEnded = (cmd, params) => this.requestEnded('COMMAND:' + cmd);

        this.cssBreakpoints = tools.entries(this.options.cssBreakpoints).sort((a, b) => a[1] - b[1]);
        this.domNode = options.domNode;
    }

    whenChanged(prop, fn) {
        this.store.addHook('listen', prop, fn);
    }

    whenLoaded(fn) {
        this.store.addHook('listen', 'appIsLoaded', fn);
    }

    requestStarted(url) {
        this.requestingUrls.push(url);
        this.store.update({'appRequestCount': this.requestingUrls.length});
        //console.log('requestStarted', this.requestingUrls.length)
    }

    requestEnded(url) {
        let p = this.requestingUrls.indexOf(url);
        if (p >= 0) {
            this.requestingUrls.splice(p, 1);
        }
        this.store.update({'appRequestCount': this.requestingUrls.length});
        //console.log('requestEnded', this.requestingUrls.length)
    }

    mounted() {
        let node = this.domNode.querySelector('.gwsMap');
        this.map.setTargetDomNode(node);
    }

    async init() {

        let res = await this.server.projectInfo({
            projectUid: this.options.projectUid
        });

        if (res.error) {
            this.fatalError(res.error.status || 500);
            return null;
        }

        console.log(res);

        this.project = res.project;

        let loc = _url2loc(location.href);
        this.urlParams = _qsparse(loc.qs);
        console.log('urlParams', this.urlParams);

        this.initialState = this.project.client.options || {};
        this.initialState.user = res.user;

        // @TODO add help configuration to the project
        this.initialState.helpUrl = this.options.defaultHelpUrl;
        this.initialState.homeUrl = this.options.defaultHomeUrl;

        this.initialState.appToolbarState = {};
        this.initialState.appActiveTool = '';

        this.map = new MapManager(this, true);
        await this.map.init(this.project.map, loc);

        if (this.project.overviewMap) {
            this.overviewMap = new MapManager(this, false);
            await this.overviewMap.init(this.project.overviewMap, {});
        }

        this.controllers['root'] = new RootController(this, {
            elements: this.rootElements(this.project.client.elements)
        });

        await this.controllers['root'].init();

        this.tools['DefaultTool'] = new DefaultTool(this, {});
        this.startTool('DefaultTool');

        this.store.update(this.initialState);

        let b = this.initialState.toolbarActiveButton;

        if (b) {
            let c = this.controllerByTag(b);
            if (c)
                c.touched();
        }

        window.onresize = () => this.onWindowResize();
        this.onWindowResize();

        window.onpopstate = () => this.onPopState();
        this.onPopState();

        console.log('APP LOADED');

        this.isLoaded = true;
        this.store.update({
            appIsLoaded: true
        });

        this.map.changed();

        return this;
    }

    initState(args) {
        this.initialState = {...args, ...this.initialState};
    }

    reload() {
        console.log('RELOAD')
        window.location.reload();
    }

    startTool(name: string) {
        console.log('START_TOOL', name);

        let currTool = this.store.getValue('appActiveTool', 'DefaultTool');
        console.log('START_TOOL:stop', currTool);
        this.tools[currTool].stop();

        console.log('START_TOOL:start', name);
        this.tools[name].start();
        this.store.update({appActiveTool: name});
    }

    stopTool(name: string) {
        let matches = (s) => (
            name[name.length - 1] === '*'
                ? s.indexOf(name.slice(0, -1)) === 0
                : s === name);

        let currTool = this.store.getValue('appActiveTool', 'DefaultTool');
        if (matches(currTool)) {
            console.log('STOP_TOOL', name, 'curr=', currTool);
            this.startTool('DefaultTool');
            return;
        }
        console.log('STOP_TOOL_MISMATCH', name, 'curr=', currTool);
    }

    toggleTool(name: string) {
        let currTool = this.store.getValue('appActiveTool', 'DefaultTool');

        if (currTool === name)
            this.startTool('DefaultTool');
        else
            this.startTool(name);

    }

    async addTool(name, obj) {
        obj.uid = name;
        this.tools[name] = obj;
        await obj.init();
        return obj;
    }

    __(key) {
        let s = this.labels[this.locale][key];
        if (s) {
            return s;
        }
        console.warn('no label for ' + key);
        return key;
    }

    createController(klass, parent, cfg) {
        let obj;

        if (klass.factory) {
            obj = klass.factory(this, cfg || {}, parent);
        } else {
            obj = new klass(this, cfg || {}, parent);
        }

        if (!obj.uid)
            obj.uid = 'uid' + String(++this.uid);
        if (!obj.tag)
            obj.tag = klass.name;

        this.controllers[obj.uid] = obj;
        return obj;
    }

    createControllerFromConfig(parent, cfg) {
        let tag = cfg.tag,
            klass;

        if (typeof tag === 'string') {
            klass = this.tags[tag];
            if (!klass) {
                throw new Error('unknown tag: ' + tag);
            }
        } else {
            klass = tag;
        }

        return this.createController(klass, parent, cfg);
    }

    controller(uid) {
        return this.controllers[uid];
    }

    controllerByTag(tag) {
        for (let [_, c] of tools.entries(this.controllers)) {
            if (c.tag === tag)
                return c;
        }
    }

    fatalError(status) {
        let html = ('<div class="uiError">' + this.__('appFatalError') + '</div>'
            + '<div class="uiErrorLongText">' + this.__('appError' + String(status)) + '</div>'
            + '<a class="uiLink" onclick="window.location.reload()">' + this.__('appErrorTryAgain') + '</a>'
            + ' | '
            + '<a class="uiLink" href="/">' + this.__('appErrorBackHome') + '</a>'
        );
        let div = document.createElement('div');
        div.className = 'appFatalError';
        div.innerHTML = html;
        this.domNode.appendChild(div);
    }

    protected onWindowResize() {
        let
            w = window.innerWidth,
            h = window.innerHeight,
            m = 'xsmall';

        this.cssBreakpoints.forEach(([name, v]) => {
            if (w >= v)
                m = name;
        });

        let up = {
            windowWidth: w,
            windowHeight: h,
            windowSize: w + 'x' + h
        };

        if (this.store.getValue('appMediaWidth') !== m)
            up['appMediaWidth'] = m;

        this.store.update(up);
        console.log('RESIZE', up);
    }

    protected rootElements(elements: Array<api.ClientProps>) {
        let shared = Object.keys(this.tags)
            .filter(tag => tag.match(/^Shared/))
            .map(tag => ({tag}));

        return shared.concat(elements);
    }

    updateLocation(data) {
        if (!this.isLoaded)
            return;

        let loc = _url2loc(location.href);

        Object.keys(data).forEach(k => {
            if (!data[k])
                delete loc[k];
            else
                loc[k] = data[k];
        });

        let url = _loc2url(loc);

        if (url !== location.href) {
            console.log('history.pushState', url);
            history.pushState({}, '', url);
        }
    }

    navigate(url, target = null) {
        location.href = url;
    }

    protected onPopState() {
        let href = location.href;
        console.log('history.popState', href);
        this.store.update({'appLocation': _url2loc(href)})
    }
}

function _url2loc(url) {

    // location = href/@x,y,scale[,rotation?][group]*
    // group = ;symbol data

    let m = url.match(/^(.*?)(\/?\?.*)?$/);

    let loc = {
        base: m[1] || '',
        qs: m[2] || '',
    };

    m = loc.base.match(/^(.*?)\/@(.*)$/);
    if (!m)
        return loc;

    loc.base = m[1];

    let h = m[2].split(';');

    loc['map'] = h[0];
    h.slice(1).forEach(s => {
        let m = s.match(/^(\w+)(.*)$/)
        if (m) {
            loc[m[1]] = m[2].trim();
        }
    });

    return loc;
}

function _loc2url(loc) {
    let hs = [];

    if (loc['map'])
        hs.push(loc['map']);

    Object.keys(loc).sort().forEach(k => {
        if (k !== 'map' && k !== 'base' && k !== 'qs')
            hs.push(k + loc[k])
    });

    let h = hs.join(';');
    return loc['base'] + (h ? '/@' + h : '') + loc.qs;
}

function _qsparse(qs) {
    let d = {};

    qs = qs.replace(/^[\/?]+/, '');

    qs.replace(/([^&=]+)=([^&]*)/g, ($0, $1, $2) => {
        let v = $2.trim();
        if (v.length > 0)
            d[decodeURIComponent($1)] = decodeURIComponent(v)
    });

    return d;
}