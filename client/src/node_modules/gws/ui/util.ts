export function className(...classNames) {
    return classNames
        .filter(Boolean)
        .map(s => String(s).trim())
        .filter(Boolean)
        .join(' ');

}

export function number(x, def: number = 0): number {
    return (typeof x === 'number') ? x : (Number(x) || def);
}

export function nextTick(fn) {
    setTimeout(fn, 0);
}

export function empty(x): boolean {
    return typeof x === 'undefined'
        || x === null
        || x === ''
        || (Array.isArray(x) && x.length < 1)
        || (typeof x === 'object' && Object.keys(x).length < 1);
}


export function constrain(n: number, min: number, max: number): number {
    if (Number.isNaN(n))
        return min;
    return Math.max(min, Math.min(max, n));
}

export function translate(x, minSrc: number, maxSrc: number, minDst: number, maxDst: number): number {
    if (minSrc === maxSrc)
        return minDst;
    x = constrain(x, minSrc, maxSrc);
    return minDst + (minDst - maxDst) * (x - minSrc) / (minSrc - maxSrc)
}

export function align(n: number, step: number, delta: number = 0): number {
    if (!step)
        return n;

    let s;

    if (delta < 0) {
        s = Math.ceil(n / step)
    } else if (delta > 0) {
        s = Math.floor(n / step)
    } else {
        s = Math.round(n / step)
    }
    return (s + delta) * step;
}

export function sign(n: number): number {
    if (n < 0) return -1;
    if (n > 0) return +1;
    return 0;
}

export function parseNumber(s): number {
    if (empty(s))
        return NaN;
    return Number(s);
}

export interface NumberFormat {
    group?: string;
    decimal?: string;
    minPrecision?: number;
    maxPrecision?: number;
}


export function formatNumber(n: number, fmt?: NumberFormat) {

    if (empty(n) || Number.isNaN(n))
        return '';

    // @TODO
    return String(n);
}

export function range(a: number, b?: number, step?: number): Array<number> {


    switch (arguments.length) {
        case 0:
            return [];
        case 1:
            b = Number(a);
            a = 0;
            step = 1;
            break;
        case 2:
            a = Number(a);
            b = Number(b);
            step = a < b ? +1 : -1;
            break;
        case 3:
            a = Number(a);
            b = Number(b);
            step = Number(step);
            break;
        default:
            return [];
    }

    if (Number.isNaN(a) || Number.isNaN(b) || Number.isNaN(step))
        return [];

    if (a < b) {
        if (step <= 0)
            return [];

        let r = [];

        while (a < b) {
            r.push(a);
            a += step;
        }
        return r;
    }

    if (a > b) {
        if (step >= 0)
            return [];

        let r = [];

        while (a > b) {
            r.push(a);
            a += step;
        }

        return r;
    }

    return [];
}
