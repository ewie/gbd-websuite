import * as React from 'react';
import * as moment from 'moment';

import * as base from './base';
import * as util from './util';

import {Touchable} from './button';
import {NumberInputBox} from './number';
import {Row, Cell} from './layout';


const DEFAULT_DATE_FORMAT = 'YYYY-MM-DD';

interface DateFormat {
    date: string;
    days?: Array<string>;
    months?: Array<string>;
}

interface DateInputProps extends base.InputProps<string> {
    minValue?: string;
    maxValue?: string;
    withClear?: boolean;
    whenEntered?: (value: string) => void;
    format?: DateFormat;
}

interface DMY {
    d: number;
    m: number;
    y: number;

}


export class DateInput extends base.Control<DateInputProps> {
    render() {
        let dmy = splitIsoDate(this.props.value),
            order = dmyOrderFromDateFormat(this.props.format ? this.props.format.date : DEFAULT_DATE_FORMAT);

        let parts = {
            D: {value: dmy.d, disabled: this.props.disabled, whenChanged: v => this.changed('d', v)},
            M: {value: dmy.m, disabled: this.props.disabled, whenChanged: v => this.changed('m', v)},
            Y: {value: dmy.y, disabled: this.props.disabled, whenChanged: v => this.changed('y', v)},
        };

        let hasFocusRef = false;

        let part = formatChar => {
            if (!parts[formatChar])
                return formatChar;
            let props = parts[formatChar];
            if (!hasFocusRef) {
                props.focusRef = this.focusRef;
                hasFocusRef = true;
            }
            return <NumberInputBox {...props}/>;
        }

        return <base.Content of={this} withClass="uiDateInput">
            <base.Box>
                {order.map((f, n) => <Cell
                        key={n}
                        className={parts[f] ? 'uiDateInput' + f : 'uiDateDelimiter'}
                    >{part(f)}</Cell>
                )}

                <Cell flex/>

                {this.props.withClear && <Cell><Touchable
                    className={'uiClearButton' + (util.empty(this.props.value) ? ' isHidden' : '')}
                    whenTouched={() => this.clear()}/></Cell>
                }
            </base.Box>
        </base.Content>
    }

    protected changed(what, val: number) {
        let dmy = splitIsoDate(this.props.value),
            p = {
                d: util.formatNumber(dmy.d),
                m: util.formatNumber(dmy.m),
                y: util.formatNumber(dmy.y),
            };
        p[what] = util.formatNumber(val);

        if (this.props.whenChanged)
            this.props.whenChanged([p.y, p.m, p.d].join('-'));
    }


    protected clear() {
        this.grabFocus();
        if (this.props.whenChanged)
            this.props.whenChanged('');
    }
}


function splitIsoDate(val): DMY {
    let s = (String(val || '').trim()).split('-');

    return {
        y: util.parseNumber(s[0]),
        m: util.parseNumber(s[1]),
        d: util.parseNumber(s[2]),
    }
}


function dmyOrderFromDateFormat(fmt) {
    // NB: we use babel formats for dates, which appears to follow
    // https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
    // this isn't always true for moment, but we only use basic d, m, y patterns

    let m = fmt.toUpperCase().match(/[A-Z]+|[^A-Z]+/g);
    return (m || []).map(t => t.match(/^[DMY]/) ? t[0] : t);
}