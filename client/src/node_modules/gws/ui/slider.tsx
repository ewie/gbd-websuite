import * as React from 'react';

import {UiComponent, UiState, UiProps} from './base';
import * as tools from '../tools';

interface TrackingSurfaceProps {
    xValueMin: number;
    xValueMax: number;
    yValueMin: number;
    yValueMax: number;

    xValue: number;
    yValue: number;

    whenPressed?: () => void;
    whenReleased?: () => void;
    whenChanged: (x: number, y: number) => void;
}

interface SliderProps extends UiProps {
    minValue: number;
    maxValue: number;
    value: number;
    label?: string;
    step?: number;
    vertical?: boolean;
    whenChanged: (value: number) => void;
    whenInteractionStarted?: () => void;
    whenInteractionStopped?: () => void;
}

interface SliderState extends UiState {
    isDown: boolean;
}

export class Slider extends UiComponent<SliderProps, SliderState> {
    rootRef: React.RefObject<any>;
    barRef: React.RefObject<any>;

    constructor(props) {
        super(props);
        this.state.isDown = false;
        this.rootRef = React.createRef();
        this.barRef = React.createRef();
    }

    render() {
        let props = {
            ...tools.cls(
                'uiSlider',
                this.state.hasFocus && 'hasFocus',
                this.props.vertical ? 'isVertical' : 'isHorizontal',
                this.state.isDown && 'isDown'),
            ...this.focusEvents(),
            ref: this.rootRef
        };

        return <div {...props}>
            {this.props.label && <div className="uiLabel">{this.props.label}</div>}

            <div className="uiControlBox">
                <div className='uiSliderBackgroundBar'/>
                <div className='uiSliderActiveBar' ref={this.barRef}/>
                <TrackingSurface
                    xValueMin={this.props.vertical ? 0 : this.props.minValue}
                    xValueMax={this.props.vertical ? 0 : this.props.maxValue}
                    yValueMin={this.props.vertical ? this.props.minValue : 0}
                    yValueMax={this.props.vertical ? this.props.maxValue : 0}
                    xValue={this.props.vertical ? 0 : this.props.value}
                    yValue={this.props.vertical ? this.props.value : 0}
                    whenPressed={() => this.whenPressed()}
                    whenReleased={() => this.whenReleased()}
                    whenChanged={(x, y) => this.whenChanged(x, y)}
                />
            </div>
        </div>
    }

    componentDidMount() {
        this.updateBars(this.props.value);
    }

    componentDidUpdate() {
        this.updateBars(this.props.value);
    }


    protected whenPressed() {
        this.setState({isDown: true});
        if (this.props.whenInteractionStarted)
            this.props.whenInteractionStarted();
    }

    protected whenReleased() {
        this.setState({isDown: false});
        if (this.props.whenInteractionStopped)
            this.props.whenInteractionStopped();
    }

    protected whenChanged(x, y) {
        let
            val = this.props.vertical ? y : x,
            step = this.props.step;

        if (step)
            val = Math.round(val / step) * step;

        val = constrain(val, this.props.minValue, this.props.maxValue);
        this.props.whenChanged(val);
        this.updateBars(val);
    }

    protected updateBars(val) {
        if (this.props.vertical) {
            let p = translate(val, this.props.minValue, this.props.maxValue, 0, this.rootRef.current.offsetHeight);
            this.barRef.current.style.height = p + 'px';
        } else {
            let p = translate(val, this.props.minValue, this.props.maxValue, 0, this.rootRef.current.offsetWidth);
            this.barRef.current.style.width = p + 'px';
        }

    }
}

export class TrackingSurface extends React.PureComponent<TrackingSurfaceProps> {
    rootRef: React.RefObject<any>;
    handleRef: React.RefObject<any>;
    handlers: any;

    xMin: number;
    xMax: number;
    yMin: number;
    yMax: number;

    dx: number;
    dy: number;

    constructor(props) {
        super(props);

        this.rootRef = React.createRef();
        this.handleRef = React.createRef();

        this.handlers = {
            mousemove: this.onMouseMove.bind(this),
            mouseup: this.onMouseUp.bind(this),
            touchmove: this.onTouchMove.bind(this),
            touchend: this.onTouchEnd.bind(this),
            touchcancel: this.onTouchCancel.bind(this)
        }
    }

    render() {
        return <button
            className="uiTrackingSurface"
            ref={this.rootRef}
            onMouseDown={e => this.onMouseDown(e)}
            onTouchStart={e => this.onTouchStart(e)}
        >
            <div className="uiTrackingSurfaceHandle" ref={this.handleRef}/>
        </button>;
    }

    componentDidMount() {
        let b = this.rootRef.current,
            h = this.handleRef.current;

        if (this.props.xValueMin === this.props.xValueMax) {
            this.xMin = this.xMax = b.offsetWidth >> 1;
        } else {
            this.xMin = h.offsetWidth >> 1;
            this.xMax = b.offsetWidth - this.xMin;
        }
        if (this.props.yValueMin === this.props.yValueMax) {
            this.yMin = this.yMax = b.offsetHeight  >> 1;
        } else {
            this.yMin = h.offsetHeight >> 1;
            this.yMax = b.offsetHeight - this.yMin;
        }

        this.dx = h.offsetWidth >> 1;
        this.dy = h.offsetHeight >> 1;

        this.updatePositionFromValues(this.props.xValue, this.props.yValue);
    }

    componentDidUpdate() {
        this.updatePositionFromValues(this.props.xValue, this.props.yValue);
    }

    componentWillUnmount() {
        this.trackStop();
    }

    //

    protected onTouchStart(e: React.TouchEvent<any>) {
        if (e.touches.length === 1) {
            this.trackStart(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault();
            e.stopPropagation();
        }
    }

    protected onMouseDown(e: React.MouseEvent<any>) {
        this.trackStart(e.clientX, e.clientY);
        e.preventDefault();
        e.stopPropagation();
    }

    protected onMouseMove(e: MouseEvent) {
        this.trackUpdate(e.clientX, e.clientY);
        e.preventDefault();
    }

    protected onMouseUp(e: MouseEvent) {
        this.trackStop();
        e.preventDefault();
    }

    protected onTouchMove(e: TouchEvent) {
        if (e.touches.length === 1) {
            this.trackUpdate(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault();
        }
    }

    protected onTouchEnd(e: TouchEvent) {
        this.trackStop();
        e.preventDefault();
    }

    protected onTouchCancel(e: TouchEvent) {
        this.trackStop();
        e.preventDefault();
    }

    //

    protected trackStart(x, y) {
        this.grabFocus();
        if (this.props.whenPressed)
            this.props.whenPressed();
        this.trackUpdate(x, y);
        this.changed();
        let doc = this.rootRef.current.ownerDocument;
        Object.keys(this.handlers).forEach(e => doc.addEventListener(e, this.handlers[e]));
    }

    protected trackStop() {
        let doc = this.rootRef.current.ownerDocument;
        Object.keys(this.handlers).forEach(e => doc.removeEventListener(e, this.handlers[e]));
        this.changed();
        if (this.props.whenReleased)
            this.props.whenReleased();
    }

    protected trackUpdate(x, y) {
        let b = this.rootRef.current,
            r = b.getBoundingClientRect();

        this.setPosition(
            constrain(x - r.left, this.xMin, this.xMax),
            constrain(y - r.top, this.yMin, this.yMax),
        );

        this.changed();
    }

    //


    protected changed() {
        let h = this.handleRef.current,
            x = h.offsetLeft + this.dx,
            y = h.offsetTop + this.dy;

        this.props.whenChanged(
            translate(x, this.xMin, this.xMax, this.props.xValueMin, this.props.xValueMax),
            translate(y, this.yMin, this.yMax, this.props.yValueMin, this.props.yValueMax)
        );
    }

    protected updatePositionFromValues(xValue, yValue) {
        this.setPosition(
            translate(xValue, this.props.xValueMin, this.props.xValueMax, this.xMin, this.xMax),
            translate(yValue, this.props.yValueMin, this.props.yValueMax, this.yMin, this.yMax));
    }

    protected setPosition(x, y) {
        let h = this.handleRef.current;
        h.style.left = (x - this.dx) + 'px';
        h.style.top = (y - this.dy) + 'px';
    }


    protected grabFocus() {
        if (this.rootRef.current)
            this.rootRef.current.focus();
    }
}

function constrain(a, min, max) {
    return Math.max(min, Math.min(max, Number(a) || 0));
}

function translate(src, minSrc, maxSrc, minDst, maxDst) {
    if (minSrc === maxSrc)
        return minDst;
    src = constrain(src, minSrc, maxSrc);
    return minDst + (minDst - maxDst) * (src - minSrc) / (minSrc - maxSrc)
}
