import * as React from 'react';

import {UiComponent, UiState, UiProps} from './base';
import * as tools from '../tools';

interface RawSliderProps {
    minValue: number;
    maxValue: number;
    value: number;
    step: number;
    vertical?: boolean;
    onPress: () => void;
    onRelease: () => void;
    onFocus: () => void;
    onBlur: () => void;
    onChange: (value: number) => void;
}

export interface SliderProps extends UiProps {
    minValue: number;
    maxValue: number;
    value: number;
    label?: string;
    step?: number;
    vertical?: boolean;
    whenChanged: (value: number) => void;
    whenInteractionStarted?: () => void;
    whenInteractionStopped?: () => void;
}

interface SliderState extends UiState {
    isDown: boolean;
}

export class Slider extends UiComponent<SliderProps, SliderState> {
    constructor(props) {
        super(props);
        this.state.isDown = false;
    }

    render() {
        return <div
            {...tools.cls(
                'uiSlider',
                this.state.hasFocus && 'hasFocus',
                this.state.isDown && 'isDown')}
        >
            {this.props.label && <div className="uiLabel">{this.props.label}</div>}

            <div className="uiControlBox">
                <RawSlider
                    minValue={this.props.minValue}
                    maxValue={this.props.maxValue}
                    value={this.props.value}
                    step={this.props.step || 1}
                    vertical={this.props.vertical}
                    onPress={() => this.onPress()}
                    onRelease={() => this.onRelease()}
                    onChange={value => this.props.whenChanged(value)}
                    {...this.focusEvents()}

                />
            </div>

        </div>
    }

    protected onPress() {
        this.setState({isDown: true});
        if (this.props.whenInteractionStarted)
            this.props.whenInteractionStarted();
    }

    protected onRelease() {
        this.setState({isDown: false});
        if (this.props.whenInteractionStopped)
            this.props.whenInteractionStopped();
    }

}

class RawSlider extends React.PureComponent<RawSliderProps> {
    rootRef: React.RefObject<any>;
    handleRef: React.RefObject<any>;
    barRef: React.RefObject<any>;
    handlers: any;

    constructor(props) {
        super(props);

        this.rootRef = React.createRef();
        this.handleRef = React.createRef();
        this.barRef = React.createRef();

        this.handlers = {
            mousemove: this.onRawMouseMove.bind(this),
            mouseup: this.onRawMouseUp.bind(this),
            touchmove: this.onRawTouchMove.bind(this),
            touchend: this.onRawTouchEnd.bind(this),
            touchcancel: this.onRawTouchCancel.bind(this)
        }
    }

    render() {
        return <button
            className="uiRawSlider"
            ref={this.rootRef}
            onMouseDown={e => this.onMouseDown(e)}
            onTouchStart={e => this.onTouchStart(e)}
            onFocus={e => this.props.onFocus()}
            onBlur={e => this.props.onBlur()}
        >
            <div className='uiControlBox'>
                <div className='uiSmallbarOuter'>
                    <div className='uiSmallbarInner' ref={this.barRef}/>
                </div>
            </div>
            <div className="uiSliderHandle" ref={this.handleRef}/>
        </button>;
    }

    componentDidMount() {
        this.updatePosition();
    }

    componentDidUpdate() {
        this.updatePosition();
    }

    componentWillUnmount() {
        this.stopInteracting();
    }

    protected onTouchStart(e: React.TouchEvent<any>) {
        console.log('TOUCH_START', e, e.touches)
        if (e.touches.length === 1)
            this.startInteracting(e.touches[0].clientX, e.touches[0].clientY);
        this.rootRef.current.focus();
        e.preventDefault();
        e.stopPropagation();
    }

    protected onMouseDown(e: React.MouseEvent<any>) {
        this.startInteracting(e.clientX, e.clientY);
        this.rootRef.current.focus();
        e.preventDefault();
    }

    protected onRawMouseMove(e: MouseEvent) {
        this.changedFromPx(e.clientX, e.clientY);
        e.preventDefault();
    }

    protected onRawMouseUp(e: MouseEvent) {
        this.stopInteracting();
        e.preventDefault();
    }

    protected onRawTouchMove(e: TouchEvent) {
        if (e.touches.length === 1)
            this.changedFromPx(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
        e.stopPropagation();
    }

    protected onRawTouchEnd(e: TouchEvent) {
        this.stopInteracting();
        e.preventDefault();
    }

    protected onRawTouchCancel(e: TouchEvent) {
        this.stopInteracting();
        e.preventDefault();
    }

    protected startInteracting(x, y) {
        this.props.onPress();
        this.changedFromPx(x, y);
        let doc = this.rootRef.current.ownerDocument;
        Object.keys(this.handlers).forEach(e => doc.addEventListener(e, this.handlers[e]));
    }

    protected stopInteracting() {
        this.props.onRelease();
        let doc = this.rootRef.current.ownerDocument;
        Object.keys(this.handlers).forEach(e => doc.removeEventListener(e, this.handlers[e]));
    }

    protected updatePosition() {
        let h = this.handleRef.current,
            b = this.barRef.current,
            p = Math.min(this.maxPx, this.valueToPx(this.props.value));

        h.style[this.props.vertical ? 'top' : 'left'] = (p || 0) + 'px';
        b.style[this.props.vertical ? 'height' : 'width'] = (p || 0) + 'px';
    }

    protected changedFromPx(x, y) {
        this.props.onChange(this.pxToValue(x, y));
    }

    protected absToRel(x, y) {
        let b = this.rootRef.current,
            rect = b.getBoundingClientRect();
        return [x - rect.left, y - rect.top];
    }

    protected get maxPx() {
        let b = this.rootRef.current,
            h = this.handleRef.current;

        return this.props.vertical
            ? b.offsetHeight - h.offsetHeight
            : b.offsetWidth - h.offsetWidth;
    }

    protected pxToValue(x, y) {
        [x, y] = this.absToRel(x, y);

        let p = this.props.vertical ? y : x,
            val = this.props.minValue + (p / this.maxPx) * (this.props.maxValue - this.props.minValue),
            step = this.props.step || 1;

        return Math.max(this.props.minValue,
            Math.min(
                Math.round(val / step) * step,
                this.props.maxValue));
    }

    protected valueToPx(value) {
        return this.maxPx * (value - this.props.minValue) / (this.props.maxValue - this.props.minValue);
    }

}
