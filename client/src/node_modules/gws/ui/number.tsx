import * as React from 'react';

import {UiComponent, UiState, UiInputProps} from './base';
import {Button} from './button';
import {Tracker} from './tracker';

import * as util from './util';

interface NumericProps extends UiInputProps<number> {
    minValue?: number;
    maxValue?: number;
    step?: number;
}

interface SliderProps extends UiInputProps<number> {
    minValue: number;
    maxValue: number;
    step?: number;
    vertical?: boolean;
    whenInteractionStarted?: () => void;
    whenInteractionStopped?: () => void;
}


interface NumberInputProps extends NumericProps {
    withClear?: boolean;
    whenEntered?: (value: number) => void;
    formatGroup?: string;
    formatDecimal?: string;
    formatPrecision?: number;
}


interface NumberInputState extends UiState {
    strValue: string;
    numValue: number;
}

const STEP_INTERVAL = 200;


export class NumberInput extends UiComponent<NumberInputProps, NumberInputState> {
    inputRef: React.RefObject<HTMLInputElement>;

    constructor(props) {
        super(props);
        this.inputRef = React.createRef();
        this.state = {
            ...this.state,
            ...stateFromNumber(props.value, props),
        }
    }


    static getDerivedStateFromProps(props, state) {
        if (props.value === state.numValue)
            return state;
        if (Number.isNaN(props.value) && Number.isNaN(state.numValue))
            return state;
        return {
            ...state,
            ...stateFromNumber(props.value, props),
        }
    }


    render() {
        let rootProps = {
            ...util.cls(
                'uiInput',
                this.props.className,
                this.state.hasFocus && 'hasFocus',
                this.props.disabled && 'isDisabled'),
            ...this.focusEvents()
        };

        let inputProps = {
            value: this.state.strValue,
            className: 'uiRawInput',
            tabIndex: 0,
            ref: this.inputRef,
            type: 'text',
            disabled: this.props.disabled,
            title: this.props.tooltip || '',
            placeholder: this.props.placeholder || '',
            onChange: e => this.onChange(e),
            onKeyDown: e => this.onKeyDown(e),
        };


        return <div {...rootProps}>
            {this.props.label && <div className="uiLabel">{this.props.label}</div>}

            <div className="uiControlBox">
                <input {...inputProps}/>

                {this.props.withClear && <Button
                    noTab
                    className={'uiInputClearButton' + (util.empty(this.state.strValue) ? ' isHidden' : '')}
                    whenTouched={() => this.clear()}/>
                }

                {this.props.step && <div className='uiNumberUpDownButton'>
                    <Tracker
                        yValueMin={-1}
                        yValueMax={+1}
                        yValue={0}
                        noHandle
                        noMove
                        whenChanged={(x, y) => this.trackDelta(-util.sign(y))}
                        idleInterval={STEP_INTERVAL}
                    />
                </div>}

            </div>
        </div>
    }


    protected onChange(e: React.SyntheticEvent<any>) {
        let s = stateFromString(e.currentTarget.value, this.props);
        this.setState(s);
        if (this.props.whenChanged)
            this.props.whenChanged(s.numValue);

    }

    protected onKeyDown(e: React.KeyboardEvent<any>) {
        if (e.key === 'Enter' && this.props.whenEntered) {
            let s = stateFromString(e.currentTarget.value, this.props);
            this.setState(s);
            this.props.whenEntered(s.numValue);
        }
    }

    protected clear() {
        let s = stateFromString('', this.props);
        this.setState(s);
        if (this.props.whenChanged)
            this.props.whenChanged(s.numValue);

        util.nextTick(() => {
            if (this.inputRef.current)
                this.inputRef.current.focus();
        });
    }

    protected trackDelta(d) {
        let n = this.state.numValue;

        n = util.align(n, this.props.step || 1, d);

        n = util.constrain(n,
            this.props.minValue || 0,
            this.props.maxValue || Infinity);

        let s = stateFromNumber(n, this.props);
        this.setState(s);
        if (this.props.whenChanged)
            this.props.whenChanged(s.numValue);

    }
}

interface SliderState extends UiState {
    isDown: boolean;
}

export class Slider extends UiComponent<SliderProps, SliderState> {
    rootRef: React.RefObject<any>;
    barRef: React.RefObject<any>;

    constructor(props) {
        super(props);
        this.state.isDown = false;
        this.rootRef = React.createRef();
        this.barRef = React.createRef();
    }

    render() {
        let rootProps = {
            ...util.cls(
                'uiSlider',
                this.props.className,
                this.state.hasFocus && 'hasFocus',
                this.props.vertical ? 'isVertical' : 'isHorizontal',
                this.state.isDown && 'isDown'),
            ...this.focusEvents(),
            ref: this.rootRef
        };

        return <div {...rootProps}>
            {this.props.label && <div className="uiLabel">{this.props.label}</div>}

            <div className="uiControlBox">
                <div className='uiSliderBackgroundBar'/>
                <div className='uiSliderActiveBar' ref={this.barRef}/>
                <Tracker
                    xValueMin={this.props.vertical ? 0 : this.props.minValue}
                    xValueMax={this.props.vertical ? 0 : this.props.maxValue}
                    yValueMin={this.props.vertical ? this.props.minValue : 0}
                    yValueMax={this.props.vertical ? this.props.maxValue : 0}
                    xValue={this.props.vertical ? 0 : this.props.value}
                    yValue={this.props.vertical ? this.props.value : 0}
                    whenPressed={() => this.whenPressed()}
                    whenReleased={() => this.whenReleased()}
                    whenChanged={(x, y) => this.whenChanged(x, y)}
                />
            </div>
        </div>
    }

    componentDidMount() {
        this.updateBars(this.props.value);
    }

    componentDidUpdate() {
        this.updateBars(this.props.value);
    }


    protected whenPressed() {
        this.setState({isDown: true});
        if (this.props.whenInteractionStarted)
            this.props.whenInteractionStarted();
    }

    protected whenReleased() {
        this.setState({isDown: false});
        if (this.props.whenInteractionStopped)
            this.props.whenInteractionStopped();
    }

    protected whenChanged(x, y) {
        let val = this.props.vertical ? y : x;

        val = util.constrain(
            util.align(val, this.props.step),
            this.props.minValue,
            this.props.maxValue);
        this.props.whenChanged(val);
        this.updateBars(val);
    }

    protected updateBars(val) {
        if (this.props.vertical) {
            let p = util.translate(val, this.props.minValue, this.props.maxValue, 0, this.rootRef.current.offsetHeight);
            this.barRef.current.style.height = p + 'px';
        } else {
            let p = util.translate(val, this.props.minValue, this.props.maxValue, 0, this.rootRef.current.offsetWidth);
            this.barRef.current.style.width = p + 'px';
        }

    }
}

//


function stateFromNumber(n: number, props: NumberInputProps) {
    return {
        strValue: util.formatNumber(n, props.formatDecimal, props.formatGroup, props.formatPrecision),
        numValue: n,
    }
}

function stateFromString(val: string, props: NumberInputProps) {
    val = val.trim();

    let sn = '',
        sg = '',
        hasDec = false;

    if (val[0] === '-') {
        if (props.minValue < 0) {
            sn += '-';
            sg += '-'
        }
        val = val.slice(1);
    }

    for (let c of val) {
        if (/\d/.test(c)) {
            sn += c;
            sg += c;
        } else if (!hasDec) {
            if (c === props.formatGroup) {
                sg += c;
            }
            else if (c === props.formatDecimal) {
                sn += '.';
                sg += c;
                hasDec = true;
            }
        }
    }

    return {
        strValue: sg,
        numValue: Number(sn),
    }
}

