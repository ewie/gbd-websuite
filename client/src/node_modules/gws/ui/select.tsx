import * as React from 'react';

import * as base from './base';
import * as util from './util';

import {Touchable} from './button';


export interface ListItem {
    text: string;
    value: any;
    level?: number;
}

interface SelectProps extends base.InputProps<string> {
    items: Array<ListItem>;
    withSearch?: boolean;
    withCombo?: boolean;
    withClear?: boolean;
}


interface SelectState extends base.ControlState {
    searchText: string;
}


export class Select extends base.Control<SelectProps, SelectState> {
    constructor(props) {
        super(props);
        this.state.searchText = '';
    }

    render() {
        let
            currentText = textFor(this.props.items, this.props.value),
            inputProps,
            inputValue,
            items = this.props.items;

        if (this.props.withSearch) {
            inputProps = {
                onKeyDown: e => this.onInputKeyDown(e),
                onChange: e => this.onInputChange(e),
            };
            inputValue = this.state.hasFocus ? this.state.searchText : currentText;
            items = filterItems(this.props.items, this.state.searchText);

        } else if (this.props.withCombo) {
            inputProps = {
                onKeyDown: e => this.onInputKeyDown(e),
                onChange: e => this.onInputChange(e),
            };
            inputValue = this.props.value;
            items = filterItems(this.props.items, this.props.value);

        } else {
            inputProps = {
                readOnly: true
            };
            inputValue = currentText;
        }

        if (util.empty(items)) {
            items = [{text: '', value: null}];
        }

        inputProps = {
            ...inputProps,
            value: inputValue,
            disabled: this.props.disabled,
            className: 'uiRawInput',
            tabIndex: 0,
            ref: this.focusRef,
            title: this.props.tooltip || '',
            placeholder: this.props.placeholder || '',
            autoComplete: '__' + Math.random(),
            onClick: e => this.onInputClick(e),
        };

        return <base.Content of={this} withClass="uiSelect">
            <base.Box>
                <input {...inputProps}/>

                {this.props.withClear && <Touchable
                    className={'uiClearButton' + (util.empty(inputValue) ? ' isHidden' : '')}
                    whenTouched={e => this.onClearClick(e)}/>
                }

                <Touchable
                    className="uiDropDownToggleButton"
                    whenTouched={e => this.onToggleClick(e)}/>

            </base.Box>

            <base.DropDown>
                <ListBox
                    value={this.props.value}
                    items={items}
                    whenSelected={val => this.whenListSelected(val)}
                />
            </base.DropDown>
        </base.Content>
    }

    //

    protected onInputChange(e: React.SyntheticEvent<HTMLInputElement>) {
        let value = e.currentTarget.value;
        this.setState(({searchText: value, isOpen: true}));

        if (this.props.withCombo)
            this.setChanged(value);
        else if (this.props.withSearch) {
            let val = valueFor(this.props.items, value);
            if (val !== null)
                this.setChanged(val);
        }

    }

    protected onInputClick(e) {
        this.setOpen(true);
    }

    protected onInputKeyDown(e) {
    }


    protected onClearClick(e) {
        this.grabFocus();
        this.setState({searchText: ''});
        this.setChanged('');
    }

    protected onToggleClick(e) {
        this.grabFocus();
        this.toggleOpen();
    }

    protected whenListSelected(val) {
        this.grabFocus();
        this.setOpen(false);
        this.setChanged(val);
    }

    //

    protected setChanged(val) {
        if (this.props.whenChanged)
            this.props.whenChanged(val);
    }

    protected filterItems(value) {
        return this.props.items.filter(it =>
            it.text.toLowerCase().startsWith(value.toLowerCase())
        );
    }

    protected whenFocusChanged(on) {
        if (!this.props.withCombo)
            this.setState({searchText: ''});
    }

    protected textFor(value) {
        let its = this.props.items.filter(it => it.value === value);
        return its.length ? its[0].text : '';
    }
}


//

interface ListProps extends base.InputProps<string> {
    items: Array<ListItem>;
}


interface ListState extends base.ControlState {
    searchText: string;
}


export class List extends base.Control<ListProps, ListState> {
    constructor(props) {
        super(props);
        this.state.searchText = '';
    }

    render() {
        let items = this.filterItems(this.state.searchText);

        return <base.Content of={this} withClass="uiList">
            <base.Box>
                <ListBox
                    value={this.props.value}
                    items={items}
                    withScroll
                    whenSelected={val => this.whenListSelected(val)}
                />
            </base.Box>
        </base.Content>
    }

    //

    protected whenListSelected(val) {
        this.grabFocus();
        this.setChanged(val);
    }

    //

    protected setChanged(val) {
        if (this.props.whenChanged)
            this.props.whenChanged(val);
    }

    protected filterItems(value) {
        return this.props.items.filter(it =>
            it.text.toLowerCase().startsWith(value.toLowerCase())
        );
    }


}

//

interface ListBoxProps {
    value: string;
    items: Array<ListItem>;
    withRef?: React.Ref<HTMLDivElement>;
    withScroll?: boolean;
    whenSelected: (value: string) => void;
}

class ListBox extends React.PureComponent<ListBoxProps> {
    selectedRef: React.RefObject<HTMLDivElement>;
    boxRef: React.RefObject<HTMLDivElement>;

    constructor(props) {
        super(props);
        this.boxRef = React.createRef();
        this.selectedRef = React.createRef();
    }

    render() {
        return <div className='uiListBox' tabIndex={-1} ref={this.boxRef}>
            {this.props.items.map(it => this.item(it))}
        </div>
    }

    componentDidMount() {
        if (this.props.withScroll)
            util.nextTick(() => this.scrollToSelected());
    }

    componentDidUpdate(prevProps) {
        if (this.props.withScroll && prevProps.value !== this.props.value)
            util.nextTick(() => this.scrollToSelected());
    }

    //

    protected item(it: ListItem) {
        let cls = util.className(
            'uiListItem',
            it.level && 'uiListItemLevel' + it.level,
            it.value === this.props.value && 'isSelected');

        return <div
            className={cls}
            key={it.value}
            ref={it.value === this.props.value ? this.selectedRef : null}
            tabIndex={-1}
            onClick={e => this.props.whenSelected(it.value)}
        >{it.text}</div>
    }

    protected scrollToSelected() {

        let box = this.boxRef.current,
            selected = this.selectedRef.current;

        if (!box || !selected)
            return;

        let padding = selected.offsetHeight;

        if (selected.offsetTop < box.scrollTop) {
            box.scrollTop = selected.offsetTop - padding;
            return;
        }
        if (selected.offsetTop + selected.offsetHeight > box.scrollTop + box.offsetHeight) {
            box.scrollTop = selected.offsetTop + selected.offsetHeight + padding - box.offsetHeight;
            return;
        }
    }
}

function textFor(items: Array<ListItem>, value: any) {
    items = items.filter(it => it.value === value);
    return items.length ? items[0].text : '';
}

function valueFor(items: Array<ListItem>, text: string) {
    items = filterItems(items, text);
    return items.length ? items[0].value : null;
}

function filterItems(items: Array<ListItem>, text: string) {
    return text ? items.filter(it => itemMatches(it, text)) : items;
}

function itemMatches(it: ListItem, text: string): boolean {
    return it.text.toLowerCase().startsWith(text.toLowerCase())
}

