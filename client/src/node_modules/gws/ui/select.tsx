import * as React from 'react';

import * as base from './base';
import * as util from './util';

import {Touchable} from './button';
import {Row, Cell} from './layout';


export interface ListItem {
    text: string;
    value: any;
    level?: number;
}

interface SelectProps extends base.InputProps<string> {
    items: Array<ListItem>;
    withSearch?: boolean;
    withCombo?: boolean;
    withClear?: boolean;
    leftButton?: (it: ListItem) => React.ReactNode;
    rightButton?: (it: ListItem) => React.ReactNode;
}


interface SelectState extends base.ControlState {
    searchText: string;
}


export class Select extends base.Control<SelectProps, SelectState> {
    constructor(props) {
        super(props);
        this.state.searchText = '';
    }

    render() {
        let
            currentText = textFor(this.props.items, this.props.value),
            inputProps,
            inputValue,
            itemBits = null;

        if (this.props.withSearch) {
            inputProps = {
                onKeyDown: e => this.onInputKeyDown(e),
                onChange: e => this.onInputChange(e),
            };
            inputValue = this.state.hasFocus ? (this.state.searchText || '') : currentText;
            itemBits = itemVisibleBits(this.props.items, this.state.searchText);

        } else if (this.props.withCombo) {
            inputProps = {
                onKeyDown: e => this.onInputKeyDown(e),
                onChange: e => this.onInputChange(e),
            };
            inputValue = this.props.value;
            itemBits = itemVisibleBits(this.props.items, this.props.value);

        } else {
            inputProps = {
                readOnly: true
            };
            inputValue = currentText;
        }

        inputProps = {
            ...inputProps,
            value: inputValue,
            disabled: this.props.disabled,
            className: 'uiRawInput',
            tabIndex: 0,
            ref: this.focusRef,
            title: this.props.tooltip || '',
            placeholder: this.props.placeholder || '',
            autoComplete: '__' + Math.random(),
            onClick: e => this.onInputClick(e),
        };

        return <base.Content of={this} withClass="uiSelect">
            <base.Box>
                <input {...inputProps}/>

                {this.props.withClear && <Touchable
                    className={'uiClearButton' + (util.empty(inputValue) ? ' isHidden' : '')}
                    whenTouched={e => this.onClearClick(e)}/>
                }

                <Touchable
                    className="uiDropDownToggleButton"
                    whenTouched={e => this.onToggleClick(e)}/>

            </base.Box>

            <base.DropDown>
                <ListBox
                    value={this.props.value}
                    items={this.props.items}
                    visibleBits={itemBits}
                    leftButton={this.props.leftButton}
                    rightButton={this.props.rightButton}
                    whenSelected={val => this.whenListSelected(val)}
                    withFlatten={this.props.withSearch && Boolean(this.state.searchText)}
                />
            </base.DropDown>
        </base.Content>
    }

    //

    protected onInputChange(e: React.SyntheticEvent<HTMLInputElement>) {
        let text = e.currentTarget.value;
        this.setState(({searchText: text, isOpen: true}));

        if (this.props.withCombo)
            this.setChanged(text);
        else if (this.props.withSearch) {
            let val = valueFor(this.props.items, text);
            if (val !== null)
                this.setChanged(val);
        }
    }

    protected onInputClick(e) {
        this.setOpen(true);
    }

    protected onInputKeyDown(e) {
    }


    protected onClearClick(e) {
        this.grabFocus();
        this.setState({searchText: ''});
        this.setChanged('');
    }

    protected onToggleClick(e) {
        this.grabFocus();
        this.toggleOpen();
    }

    protected whenListSelected(val) {
        this.grabFocus();
        this.setOpen(false);
        this.setChanged(val);
        if (this.props.withSearch) {
            let text = textFor(this.props.items, val);
            this.setState({searchText: text});
        }
    }

    //

    protected setChanged(val) {
        if (this.props.whenChanged)
            this.props.whenChanged(val);
    }

    protected filterItems(value) {
        return this.props.items.filter(it =>
            it.text.toLowerCase().startsWith(value.toLowerCase())
        );
    }

    protected whenFocusChanged(on) {
        if (!this.props.withCombo)
            this.setState({searchText: ''});
    }

    protected textFor(value) {
        let its = this.props.items.filter(it => it.value === value);
        return its.length ? its[0].text : '';
    }
}


//

interface ListProps extends base.InputProps<string> {
    items: Array<ListItem>;
    leftButton?: (it: ListItem) => React.ReactNode;
    rightButton?: (it: ListItem) => React.ReactNode;
}


interface ListState extends base.ControlState {
    searchText: string;
}


export class List extends base.Control<ListProps, ListState> {
    constructor(props) {
        super(props);
        this.state.searchText = '';
    }

    render() {
        let items = this.filterItems(this.state.searchText);

        return <base.Content of={this} withClass="uiList">
            <base.Box>
                <ListBox
                    value={this.props.value}
                    items={items}
                    withScroll
                    leftButton={this.props.leftButton}
                    rightButton={this.props.rightButton}
                    whenSelected={val => this.whenListSelected(val)}
                />
            </base.Box>
        </base.Content>
    }

    //

    protected whenListSelected(val) {
        this.grabFocus();
        this.setChanged(val);
    }

    //

    protected setChanged(val) {
        if (this.props.whenChanged)
            this.props.whenChanged(val);
    }

    protected filterItems(value) {
        return this.props.items.filter(it =>
            it.text.toLowerCase().startsWith(value.toLowerCase())
        );
    }


}

//

interface ListBoxProps {
    value: string;
    items: Array<ListItem>;
    visibleBits?: Array<boolean>;
    focusRef?: React.Ref<any>;
    withScroll?: boolean;
    withFlatten?: boolean;
    whenSelected: (value: string) => void;
    leftButton?: (it: ListItem) => React.ReactNode;
    rightButton?: (it: ListItem) => React.ReactNode;
}

class ListBox extends React.PureComponent<ListBoxProps> {
    selectedRef: React.RefObject<HTMLDivElement>;
    boxRef: React.RefObject<HTMLDivElement>;

    constructor(props) {
        super(props);
        this.boxRef = React.createRef();
        this.selectedRef = React.createRef();
    }

    render() {
        return <div className='uiListBox' tabIndex={-1} ref={this.boxRef}>
            {this.items()}
        </div>
    }

    componentDidMount() {
        if (this.props.withScroll)
            util.nextTick(() => this.scrollToSelected());
    }

    componentDidUpdate(prevProps) {
        if (this.props.withScroll && prevProps.value !== this.props.value)
            util.nextTick(() => this.scrollToSelected());
    }

    //

    protected items() {
        let headers = {};

        return this.props.items.map((it, n) => {
            if (it.level)
                headers[it.level] = it.text;
            if (this.props.visibleBits && !this.props.visibleBits[n])
                return null;
            return <ListBoxItem
                key={n}
                selected={it.value === this.props.value}
                item={it}
                parentText={headers[it.level - 1]}
                selectedRef={this.selectedRef}
                whenSelected={this.props.whenSelected}
                leftButton={this.props.leftButton}
                rightButton={this.props.rightButton}
                withFlatten={this.props.withFlatten}
            />
        });
    }

    protected scrollToSelected() {

        let box = this.boxRef.current,
            selected = this.selectedRef.current;

        if (!box || !selected)
            return;

        let padding = selected.offsetHeight;

        if (selected.offsetTop < box.scrollTop) {
            box.scrollTop = selected.offsetTop - padding;
            return;
        }
        if (selected.offsetTop + selected.offsetHeight > box.scrollTop + box.offsetHeight) {
            box.scrollTop = selected.offsetTop + selected.offsetHeight + padding - box.offsetHeight;
            return;
        }
    }
}

interface ListBoxItemProps {
    selected: boolean;
    item: ListItem;
    parentText?: string;
    selectedRef: React.Ref<HTMLDivElement>;
    whenSelected: (value: string) => void;
    leftButton?: (it: ListItem) => React.ReactNode;
    rightButton?: (it: ListItem) => React.ReactNode;
    withFlatten: boolean;
}


class ListBoxItem extends base.Pure<ListBoxItemProps> {
    render() {
        let cls = util.className(
            'uiListItem',
            this.props.item.level && 'uiListItemLevel' + this.props.item.level,
            this.props.withFlatten && 'isFlat',
            this.props.selected && 'isSelected');

        let text = this.props.withFlatten && this.props.parentText
            ? <React.Fragment>
                {this.props.item.text}
                <span className='uiListItemParentLevelText'>{this.props.parentText}</span>
            </React.Fragment>
            : this.props.item.text;

        return <div
            className={cls}
            ref={this.props.selected ? this.props.selectedRef : null}
        >
            {this.props.leftButton && <Cell>{this.props.leftButton(this.props.item)}</Cell>}
            <Cell flex className='uiListItemText'>
                <Touchable
                    whenTouched={e => this.props.whenSelected(this.props.item.value)}
                >{text}</Touchable>
            </Cell>
            {this.props.rightButton && <Cell>{this.props.rightButton(this.props.item)}</Cell>}
        </div>
    }
}

function textFor(items: Array<ListItem>, value: any) {
    for (let it of items) {
        if (it.value === value) {
            return it.text;
        }
    }
    return '';
}

function valueFor(items: Array<ListItem>, text: string) {
    if (!text) {
        return items[0].value;
    }
    for (let it of items) {
        if (itemMatches(it, text)) {
            return it.value;
        }
    }
    return null;
}

function itemVisibleBits(items: Array<ListItem>, text: string) {
    return text ? items.map(it => itemMatches(it, text)) : null;
}

function itemMatches(it: ListItem, text: string): boolean {
    return it.text.toLowerCase().startsWith(text.toLowerCase())
}

