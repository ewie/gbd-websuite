import * as ol from 'openlayers';

import * as types from '../types';
import * as api from '../core/gws-api';
import * as tools from '../tools';

const DEFAULTS = {
    marker_size: 10,
    point_size: 10,
    label_placement: api.StyleLabelPlacement.middle,
    label_max_scale: 1000000000,
    label_min_scale: 0,
    label_font_size: 10,
    label_line_height: 1,
    label_font_family: 'sans-serif',
    label_font_weight: api.StyleLabelFontWeight.normal,
    label_font_style: api.StyleLabelFontStyle.normal,
};

let _uid = 0;

function autoName() {
    _uid++;
    return 'Style' + _uid;
}

export class StyleManager implements types.IStyleManager {
    styles: { [name: string]: Style } = {};
    defaultStyle: Style;

    constructor() {
        this.defaultStyle = new Style('', {});
    }

    get names() {
        return Object.keys(this.styles);
    }

    at(name: string): Style {
        return this.styles[name] || this.defaultStyle;
    }

    get(style: types.StyleArg): Style {
        if (!style) {
            return this.defaultStyle;
        }

        if (style instanceof Style) {
            return style;
        }

        if (typeof style === 'string') {
            return this.getFromNameOrSelector(style);
        }

        if (typeof style === 'object') {
            let props = style as api.StyleProps;

            if (props.type === api.StyleType.cssSelector) {
                return this.getFromNameOrSelector(props.text);
            }

            if (props.type === api.StyleType.css) {
                if (props.values) {
                    return this.create(props.values);
                }

                let values = valuesFromCssText(props.text || '');

                if (values) {
                    return this.create(values);
                }

                console.warn('style:invalid css', style);
                return this.defaultStyle;
            }
        }

        console.warn('style:invalid style', style);
        return this.defaultStyle;
    }

    update(name: string, values: api.StyleValues): types.IStyle | null {
        let s = this.styles[name];
        if (!s)
            return null;
        this.styles[name] = new Style(name, {...s.values, ...values});
    }

    makeMap(src) {
        let m: types.StyleNameMap = {
            normal: '', selected: '', edit: ''
        };

        m.normal = this.nameFor(src.normal);
        m.selected = this.nameFor(src.selected);
        m.edit = this.nameFor(src.edit);

        return m;
    }


    functionFor(style: types.StyleArg): ol.StyleFunction | null {
        let s = this.get(style);

        if (!s)
            return null;

        return function (oFeature: ol.Feature, resolution: number): Array<ol.style.Style> {
            return s.apply(oFeature.getGeometry(), oFeature.get('label'), resolution);
        }
    }

    propsFor(style: types.StyleArg): api.StyleProps | null {
        let s = this.get(style);
        return s ? s.props : null;
    }

    nameFor(style: types.StyleArg): string | null {
        let s = this.get(style);
        return s ? s.name : null;
    }

    notifyChange(map, name) {
        map.walk(map.root, layer => {
            if (layer['styleNames'] && (!name || name === layer['styleNames']['normal'])) {
                layer.changed()
                return;
            }
            layer.oFeatures.forEach(f => {
                if (f['_gwsFeature'] && (!name || name === f['_gwsFeature']['currentStyleName']))
                    f.changed();
            });
        });
    }

    unserialize(data: object) {
        this.styles = {};
        Object.keys(data).forEach(k =>
            this.styles[k] = new Style(k, data[k])
        );
    }

    serialize() {
        let data = {}
        Object.keys(this.styles).forEach(k =>
            data[k] = this.styles[k].values
        );
        return data;
    }


    protected getFromNameOrSelector(name: string) {
        if (this.styles[name]) {
            return this.styles[name];
        }

        let values = valuesFromCssSelector(name);
        if (values) {
            return this.create(values, name);
        }

        console.warn('style:not found', name);
        return this.defaultStyle;
    }

    protected create(values: api.StyleValues, name = null) {
        name = name || autoName();
        let s = new Style(name, values);
        this.styles[name] = s;
        return s;
    }

}


export class Style implements types.IStyle {
    map: types.IMapManager;

    name: string;
    text: string;
    values: api.StyleValues;

    markerImage: ol.style.Image;
    pointImage: ol.style.Image;
    shapeStyle: ol.style.Style;
    labelOptions: types.Dict;

    labelMaxResolution: number;
    labelMinResolution: number;

    constructor(name: string, values: api.StyleValues) {
        this.name = name;
        this.values = {...DEFAULTS, ...values};

        let fill = olMakeFill(this.values),
            stroke = olMakeStroke(this.values);

        if (fill || stroke) {
            this.shapeStyle = new ol.style.Style(compact({fill, stroke}));

            if (this.values.point_size) {
                this.pointImage = new ol.style.Circle(compact({
                    fill, stroke, radius: this.values.point_size >> 1
                }))
            }
        }

        this.markerImage = olMakeMarker(this.values);
        this.labelOptions = olLabelOptions(this.values);

        this.labelMaxResolution = tools.scale2res(this.values.label_max_scale);
        this.labelMinResolution = tools.scale2res(this.values.label_min_scale);
    }

    apply(geom, label, resolution) {

        let gt = geom.getType(),
            styles = [];

        if (this.shapeStyle) {
            if (gt === 'Point' || gt === 'MultiPoint') {
                if (this.pointImage) {
                    styles.push(new ol.style.Style({
                        image: this.pointImage,
                        geometry: geom,
                    }))
                }
            } else {
                styles.push(this.shapeStyle);
            }
        }

        if (this.markerImage) {
            styles.push(new ol.style.Style({
                image: this.markerImage,
                geometry: geometryForMarker(geom)
            }))
        }

        if (label && this.labelOptions && this.labelMinResolution <= resolution && resolution <= this.labelMaxResolution) {

            let r = {
                    text: new ol.style.Text({
                        ...this.labelOptions,
                        text: label
                    })
                },
                coord = labelPlacementCoord(geom, this.values.label_placement);

            if (coord) {
                r['geometry'] = new ol.geom.Point(coord);
            }

            styles.push(new ol.style.Style(r));
        }

        return styles;
    }

    get props() {
        return {
            'type': api.StyleType.css,
            'values': this.values,
            'text': '',
        }
    }
}

//

function geometryForMarker(geom) {
    let gt = geom.getType();

    if (gt === 'Point' || gt === 'Multipoint') {
        return geom
    }

    let bounds;

    if (gt === 'Polygon') {
        bounds = geom.getLinearRing(0).getCoordinates();
    } else if (gt === 'MultiPolygon') {
        bounds = geom.getPolygon(0).getLinearRing(0).getCoordinates();
    } else if (gt === 'Circle') {
        bounds = geom.getCenter();
    } else {
        bounds = geom.getCoordinates();
    }

    return new ol.geom.MultiPoint(bounds);

}

function labelPlacementCoord(geom, where) {

    let gt = geom.getType();

    if (gt === 'Point' || gt === 'MultiPoint' || where === 'start') {
        return geom.getFirstCoordinate()
    }

    if (gt === 'Circle') {
        return geom.getCenter();
    }

    if (where === 'end')
        return geom.getLastCoordinate()
}

//

function olMakeFill(vs, prefix = '') {
    let color = vs[prefix + 'fill'];
    if (color)
        return new ol.style.Fill({color});
}

function olMakeStroke(vs, prefix = '') {
    let r = compact({
        color: vs[prefix + 'stroke'],
        lineDash: vs[prefix + 'stroke_dasharray'],
        lineDashOffset: vs[prefix + 'stroke_dashoffset'],
        lineCap: vs[prefix + 'stroke_linecap'],
        lineJoin: vs[prefix + 'stroke_linejoin'],
        miterLimit: vs[prefix + 'stroke_miterlimit'],
        width: vs[prefix + 'stroke_width'],
    });

    if (r)
        return new ol.style.Stroke(r);
}

function olMakeMarker(vs) {
    let marker = vs.marker,
        size = vs.marker_size;

    if (marker === 'circle' && size) {
        let r = compact({
            fill: olMakeFill(vs, 'marker_'),
            stroke: olMakeStroke(vs, 'marker_'),
            radius: size >> 1
        });

        if (r)
            return new ol.style.Circle(r);
    }
}

function olLabelOptions(vs) {
    if (!vs.label_fill)
        return;

    let font = `${vs.label_font_style} ${vs.label_font_weight} ${vs.label_font_size}px/${vs.label_line_height} ${vs.label_font_family}`;

    let r = compact({
        font,
        overflow: true,
        fill: olMakeFill(vs, 'label_'),
        stroke: olMakeStroke(vs, 'label_')
    });

    let v;

    if (v = vs.label_background)
        r['backgroundFill'] = new ol.style.Fill({color: v});

    if (v = vs.label_align)
        r['textAlign'] = v;

    if (v = vs.label_padding)
        r['padding'] = v;

    if (v = vs.label_offset_x)
        r['offsetX'] = v;

    if (v = vs.label_offset_y)
        r['offsetY'] = v;

    return r;
}


//

function each(coll, fn) {
    for (let i = 0; i < coll.length; i++)
        fn(coll[i]);
}

function empty(x) {
    return typeof x === 'undefined' || x === null || x === '' || Number.isNaN(x);
}

function compact(obj): any {
    let d = {}, c = 0;

    each(Object.keys(obj), k => {
        if (!empty(obj[k])) {
            d[k] = obj[k];
            c++;
        }
    });

    return c ? d : null;
}


// 

function valuesFromCssSelector(selector: string): api.StyleValues {


    function getStyleSheets() {
        try {
            // there can be stuff we're not allowed to read
            return document.styleSheets;
        } catch (e) {
            return [];
        }
    }

    function getRules(styleSheet) {
        try {
            return styleSheet.rules || styleSheet.cssRules || [];
        } catch (e) {
            return [];
        }
    }

    function matches(a, b) {
        return a && (a === b || String(a).endsWith(' ' + b));
    }

    let res = [];

    each(getStyleSheets(), s =>
        each(getRules(s), r => {
            if (matches(r.selectorText, selector) && r.style)
                res.push(r.style.cssText);
        })
    );

    let text = res.length ? res.pop() : null;

    console.log('SELECTOR', selector, text, valuesFromCssText(text))


    if (text)
        return valuesFromCssText(text);
}

// below is what we have in tools/style.py


let _color_patterns = [
    /^#[0-9a-fA-F]{6}$/,
    /^#[0-9a-fA-F]{8}$/,
    /^rgb\(\d{1,3},\d{1,3},\d{1,3}\)$/,
    /^rgba\(\d{1,3},\d{1,3},\d{1,3},\d?(\.\d{1,3})?\)$/,
    /^[a-z]{3,50}$/,
];


let _color = (val) => {
    val = val.replace(/\s+/g, '');
    if (_color_patterns.some(p => val.match(p)))
        return val
};

let _px = (val) => {
    let m = val.match(/^(-?\d+)px/);
    return _int(m ? m[1] : val);
};

let _int = (val) => {
    val = Number(val);
    if (!Number.isNaN(val))
        return val;
};

let _intlist = (val) => {
    val = val.split(/[,\s]+/).map(_int);
    if (val.every(x => typeof x === 'number'))
        return val;
};

let _padding = (val) => {
    val = val.split(/[,\s]+/).map(_px);
    if (val.every(x => typeof x === 'number')) {
        if (val.length === 4)
            return val;
        if (val.length === 2)
            return [val[0], val[1], val[0], val[1]];
        if (val.length === 1)
            return [val[0], val[0], val[0], val[0]];
    }
};

let _enum = (cls) => {
    let _check = (val) => {
        if (val in cls)
            return val
    }
    return _check
};

let _str = (val) => {
    val = val.trim()
    return val || (void 0);
};

let _Parser: any = {};

_Parser.fill = _color;
_Parser.stroke = _color;
_Parser.stroke_dasharray = _intlist;
_Parser.stroke_dashoffset = _px;
_Parser.stroke_linecap = _enum(api.StyleStrokeLineCap);
_Parser.stroke_linejoin = _enum(api.StyleStrokeLineJoin);
_Parser.stroke_miterLimit = _px;
_Parser.stroke_width = _px;
_Parser.marker = _enum(api.StyleMarker);
_Parser.marker_fill = _color;
_Parser.marker_size = _px;
_Parser.marker_stroke = _color;
_Parser.marker_stroke_width = _px;
_Parser.label_align = _enum(api.StyleLabelAlign);
_Parser.label_background = _color;
_Parser.label_fill = _color;
_Parser.label_font_family = _str;
_Parser.label_font_size = _px;
_Parser.label_font_style = _enum(api.StyleLabelFontStyle);
_Parser.label_font_weight = _enum(api.StyleLabelFontWeight);
_Parser.label_line_height = _int;
_Parser.label_max_scale = _int;
_Parser.label_min_scale = _int;
_Parser.label_offset_x = _px;
_Parser.label_offset_y = _px;
_Parser.label_padding = _padding;
_Parser.label_placement = _enum(api.StyleLabelPlacement);
_Parser.label_stroke = _color;
_Parser.label_stroke_width = _px;
_Parser.label_width = _px;
_Parser.point_size = _px;


//

function valuesFromCssDict(d: types.Dict): api.StyleValues {
    let values = {};

    Object.keys(d).forEach(k => {
        let v = d[k];

        k = k.replace(/-/g, '_');
        if (k.startsWith('__'))
            k = k.slice(2);

        let fn = _Parser[k];
        if (fn) {
            v = fn(v);
            if (typeof v !== 'undefined')
                values[k] = v;
        }
    });

    return values as api.StyleValues;
}

function valuesFromCssText(text: string): api.StyleValues {
    let d = {};

    each(text.split(';'), r => {
        r = r.trim();
        if (!r)
            return;
        let s = r.split(':');
        d[s[0].trim()] = s[1].trim();
    });

    return valuesFromCssDict(d);
}
