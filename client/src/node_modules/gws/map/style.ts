import * as ol from 'openlayers';

import * as types from '../types';
import * as api from '../core/gws-api';

const _CSS_DEFAULTS = {
    'mark-size': '10px',
    'point-size': '10px',
    'label-placement': 'middle',
    'label-max-resolution': '1000000000',
    'label-min-resolution': '0',
    'label-font-size': '10px',
    'label-line-height': '1',
    'label-font-family': 'sans-serif',
};

export class CssStyle implements types.IMapStyle {
    map: types.IMapManager;
    values = {};
    source = '';

    markImage?: ol.style.Image;
    pointImage?: ol.style.Image;
    shapeStyle?: ol.style.Style;
    labelOpts?: types.Dict;

    labelPlacement: string;
    labelMaxResolution: number;
    labelMinResolution: number;

    static fromSelector(map, selector) {
        let source = getSource(selector);
        if (!source)
            console.warn('selector not found:', selector);
        return new this(map, source || '')
    }

    static fromSource(map, source) {
        return new this(map, source || '')
    }

    constructor(map, source) {
        this.map = map;

        this.source = source;
        this.values = Object.assign(
            {},
            _CSS_DEFAULTS,
            stripPrefix(typeof source === 'string' ? toDict(source) : source))

        this.markImage = parseMark(this.values);
        this.labelOpts = parseLabel(this.values);

        let fill = parseFill(this.values, ''),
            stroke = parseStroke(this.values, '');

        if (fill || stroke) {
            this.shapeStyle = new ol.style.Style(compact({fill, stroke}));

            let pointSize = pxValue(this.values['point-size']);

            if (pointSize > 0) {
                this.pointImage = new ol.style.Circle(compact({
                    fill, stroke, radius: pointSize >> 1
                }))
            }
        }

        this.labelPlacement = this.values['label-placement'];
        this.labelMaxResolution = numValue(this.values['label-max-resolution']);
        this.labelMinResolution = numValue(this.values['label-min-resolution']);
    }

    apply(geom, label, resolution) {

        let gt = geom.getType(),
            styles = [];

        if (this.shapeStyle) {
            if (gt === 'Point' || gt === 'MultiPoint') {
                styles.push(new ol.style.Style({
                    image: this.pointImage,
                    geometry: geom,
                }))
            } else {
                styles.push(this.shapeStyle);
            }
        }

        if (this.markImage) {
            styles.push(new ol.style.Style({
                image: this.markImage,
                geometry: markGeometry(geom)
            }))
        }

        if (label && this.labelOpts && this.labelMinResolution <= resolution && resolution <= this.labelMaxResolution) {

            let r = {text: new ol.style.Text({...this.labelOpts, text: label})},
                coord = labelPlacementCoord(geom, this.labelPlacement);

            if (coord) {
                r['geometry'] = new ol.geom.Point(coord);
            }
            styles.push(new ol.style.Style(r));
        }

        return styles;
    }

    get props() {
        return {
            'type': api.StyleType.css,
            'content': this.values,
            'text': '',
        }
    }
}

//

function getSource(selector) {
    let res = [];

    each(getStyleSheets(), s =>
        each(getRules(s), r => {
            if (matches(r.selectorText, selector) && r.style)
                res.push(r.style.cssText);
        })
    );
    return res.length ? res.pop() : null;
}

function getStyleSheets() {
    try {
        // there can be stuff we're not allowed to read
        return document.styleSheets;
    } catch (e) {
        return [];
    }
}

function getRules(styleSheet) {
    try {
        return styleSheet.rules || styleSheet.cssRules || [];
    } catch (e) {
        return [];
    }
}

function matches(a, b) {
    return a && (a === b || String(a).endsWith(' ' + b));
}

function toDict(text) {
    let d = {};

    each(text.split(';'), line => {
        if (line && String(line).trim()) {
            let m = line.match(/^([\w\s-]+):(.+)$/);
            if (!m) {
                console.warn('cannot parse "' + line + '"');
                return;
            }
            d[m[1].trim()] = m[2].trim();
        }
    });

    return d;
}

function stripPrefix(css) {
    let d = {};

    each(Object.keys(css), k =>
        d[k.replace(/^--/, '')] = css[k]
    );

    return d;
}

//

function parseMark(css) {
    let mark = css['mark'],
        size = pxValue(css['mark-size']);

    if (!mark || size <= 0)
        return;

    if (mark === 'circle') {
        let r: any = compact({
            fill: parseFill(css, 'mark-'),
            stroke: parseStroke(css, 'mark-'),
            radius: size >> 1
        });

        if (r)
            return new ol.style.Circle(r);
    }
}

function parseLabel(css) {
    if (!css['label-fill'])
        return;

    let font =
        (css['label-font-style'] || '')
        + ' ' + (css['label-font-weight'] || '')
        + ' ' + String(pxValue(css['label-font-size'])) + 'px'
        + '/' + String(pxValue(css['label-line-height']))
        + ' ' + (css['label-font-family']);

    let r = compact({
        font: font.trim(),
        overflow: true,
        fill: parseFill(css, 'label-'),
        stroke: parseStroke(css, 'label-')
    });

    let v;

    if (v = css['label-background'])
        r['backgroundFill'] = new ol.style.Fill({color: v});

    if (v = css['label-anchor'])
        r['textAlign'] = v;

    if (v = css['label-padding'])
        r['padding'] = paddingValue(v);

    if (v = css['label-offset-x'])
        r['offsetX'] = pxValue(v);

    if (v = css['label-offset-y'])
        r['offsetY'] = pxValue(v);

    return r;
}

function parseFill(css, prefix) {
    let color = css[prefix + 'fill'];
    if (color)
        return new ol.style.Fill({color});
}

function parseStroke(css, prefix) {
    let r: any = compact({
        color: css[prefix + 'stroke'],
        lineDash: lineDashValue(css[prefix + 'stroke-dasharray']),
        lineDashOffset: numValue(css[prefix + 'stroke-dashoffset']),
        lineCap: css[prefix + 'stroke-linecap'],
        lineJoin: css[prefix + 'stroke-linejoin'],
        miterLimit: css[prefix + 'stroke-miterlimit'],
        width: pxValue(css[prefix + 'stroke-width']),
    });

    if (r)
        return new ol.style.Stroke(r);
}

//

function paddingValue(val) {
    val = String(val).split(' ');
    if (val.length == 1) {
        let p = pxValue(val[0]);
        return [p, p, p, p];
    }
    if (val.length == 2) {
        let p = pxValue(val[0]),
            q = pxValue(val[1]);
        return [p, q, p, q];
    }
    return val.map(pxValue);
}

function lineDashValue(val) {
    return val ? val.split(/[,\s]+/g).map(pxValue) : null;
}

function pxValue(val) {
    let m = String(val || '').match(/^(-?\d+)(|px)/);
    if (m && (m[2] === '' || m[2] === 'px'))
        return Number(m[1])
}

function numValue(val) {
    return parseFloat(val);
}

//

function each(coll, fn) {
    for (let i = 0; i < coll.length; i++)
        fn(coll[i]);
}

function empty(x) {
    return typeof x === 'undefined' || x === null || x === '' || Number.isNaN(x);
}

function compact(obj): any {
    let d = {}, c = 0;

    each(Object.keys(obj), k => {
        if (!empty(obj[k])) {
            d[k] = obj[k];
            c++;
        }
    });

    return c ? d : null;
}

//

function markGeometry(geom) {
    let gt = geom.getType();

    if (gt === 'Point' || gt === 'Multipoint') {
        return geom
    }

    let bounds;

    if (gt === 'Polygon') {
        bounds = geom.getLinearRing(0).getCoordinates();
    } else if (gt === 'MultiPolygon') {
        bounds = geom.getPolygon(0).getLinearRing(0).getCoordinates();
    } else if (gt === 'Circle') {
        bounds = geom.getCenter();
    } else {
        bounds = geom.getCoordinates();
    }

    return new ol.geom.MultiPoint(bounds);

}

function labelPlacementCoord(geom, where) {

    let gt = geom.getType();

    if (gt === 'Point' || gt === 'MultiPoint' || where === 'start') {
        return geom.getFirstCoordinate()
    }

    if (gt === 'Circle') {
        return geom.getCenter();
    }

    if (where === 'end')
        return geom.getLastCoordinate()
}
