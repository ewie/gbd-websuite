import * as ol from 'openlayers';
import * as _ from 'lodash';

import * as types from '../types';
import * as tools from '../tools';

let styleClasses = {
    'circle': ol.style.Circle,
    'fill': ol.style.Fill,
    'icon': ol.style.Icon,
    'image': ol.style.Image,
    'shape': ol.style.RegularShape,
    'stroke': ol.style.Stroke,
    'style': ol.style.Style,
    'text': ol.style.Text,
};

function each(coll, fn) {
    for (let i = 0; i < coll.length; i++)
        fn(coll[i]);
}

function matches(a, b) {
    return a && (a === b || String(a).endsWith(' ' + b));
}

function getRules(styleSheet) {
    try {
        return styleSheet.rules || styleSheet.cssRules || [];
    } catch (e) {
        return [];
    }

}

function findCss(selector) {
    let res = [];

    // there can be stuff we're not allowed to read
    let styleSheets;

    try {
        styleSheets = document.styleSheets;
    } catch (e) {
        return null;

    }

    each(styleSheets, s =>
        each(getRules(s), r => {
            if (matches(r.selectorText, selector) && r.style)
                res.push(r.style.cssText);
        })
    );

    return res.length ? res[0] : null;
}

function js2MapStyle(js): ol.style.Style | ol.style.Image {

    function convert(o) {
        if (!_.isPlainObject(o)) {
            return o;
        }
        return _.mapValues(o, (props, key) => {
            if (styleClasses[key])
                return new styleClasses[key](convert(props));
            return convert(props);

        })
    }

    return _.values(convert(js))[0];
}

function toDict(text) {
    let d = {};

    each(text.split(';'), line => {
        if (line && String(line).trim()) {
            let m = line.match(/^([\w\s-]+):(.+)$/);
            d[m[1].trim()] = m[2].trim();
        }
    });

    return d;
}

function stripPrefix(css) {
    let d = {};
    tools.entries(css).forEach(([k, v]) => d[k.replace(/^--/, '')] = v);
    return d;
}

function pxValue(val) {
    let m = String(val || '').match(/^(-?\d+)(|px)/);
    if (m && (m[2] === '' || m[2] === 'px'))
        return Number(m[1])
}

function numValue(val) {
    return parseFloat(val);
}

function padding(val) {
    val = String(val).split(' ');
    if (val.length == 1) {
        let p = pxValue(val[0]);
        return [p, p, p, p];
    }
    if (val.length == 2) {
        let p = pxValue(val[0]),
            q = pxValue(val[1]);
        return [p, q, p, q];
    }
    return val.map(pxValue);
}

function colorValue(val) {
    let m;
    if (m = val.match(/^rgba?\((.+?)\)/))
        return m[1].split(',').map(Number);
    if (m = val.match(/^#(..)(..)(..)/))
        return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16)];

}

function set(r, keys, val) {
    let ks = keys.split('.'), last = ks.pop();
    each(ks, k => r = r[k] || (r[k] = {}));
    r[last] = val;
}

let strokeProps = [
    'stroke',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-width',
];

function parseFill(opts, css, prefix) {
    let color = css[prefix + 'fill'];
    if (color)
        opts['fill'] = new ol.style.Fill({color});
}

function parseStroke(opts, css, prefix) {
    let r: any = {};

    strokeProps.forEach(prop => {
        let val = css[prefix + prop];

        if (tools.empty(val))
            return;

        switch (prop) {
            case 'stroke':
                return r['color'] = val;
            case 'stroke-dasharray':
                return r['lineDash'] = val.split(/[,\s]+/g).map(pxValue);
            case 'stroke-dashoffset':
                return r['lineDashOffset'] = Number(val);
            case 'stroke-linecap':
                return r['lineCap'] = val;
            case 'stroke-linejoin':
                return r['lineJoin'] = val;
            case 'stroke-miterlimit':
                return r['miterLimit'] = val;
            case 'stroke-width':
                return r['width'] = pxValue(val);
        }
    });

    if (!tools.empty(r))
        opts['stroke'] = new ol.style.Stroke(r);
}

function parseImage(opts, css) {
    let r: any = {};

    let mark = css['mark'];
    if (!mark)
        return;

    let size = pxValue(css['mark-size']) || 10;

    parseFill(r, css, 'mark-');
    parseStroke(r, css, 'mark-');

    switch (mark) {
        case 'circle':
            r.radius = size >> 1;
            return opts['image'] = new ol.style.Circle(r);
    }
}

function parseText(opts, css) {
    if (!css['label-fill'])
        return;

    let font =
        (css['label-font-style'] || '')
        + ' ' + (css['label-font-weight'] || '')
        + ' ' + String(pxValue(css['label-font-size']) || 10) + 'px'
        + '/' + String(pxValue(css['label-line-height']) || '1')
        + ' ' + (css['label-font-family'] || 'sans-serif');

    let r = {
        font: font.trim(),
        overflow: true
    };

    parseFill(r, css, 'label-');
    parseStroke(r, css, 'label-');

    let v;

    if (v = css['label-background'])
        r['backgroundFill'] = new ol.style.Fill({color: v});

    if (v = css['label-anchor'])
        r['textAlign'] = v;

    if (v = css['label-padding'])
        r['padding'] = padding(v);

    if (v = css['label-offset-x'])
        r['offsetX'] = pxValue(v);

    if (v = css['label-offset-y'])
        r['offsetY'] = pxValue(v);

    opts['text'] = new ol.style.Text(r);
}

function parse(css) {
    let opts: any = {};

    parseImage(opts, css);
    parseFill(opts, css, '');
    parseStroke(opts, css, '');
    parseText(opts, css);

    if (!tools.empty(opts))
        return new ol.style.Style(opts);
}

function parseExtras(css) {
    let opts: any = {};

    opts['label-placement'] = css['label-placement'] || 'middle';
    opts['label-max-resolution'] = numValue(css['label-max-resolution']) || 1e20;
    opts['label-min-resolution'] = numValue(css['label-min-resolution']) || 0;

    return opts;
}

function markBounds(geom) {
    switch (geom.getType()) {

        case 'Point':
            return geom;
        case 'LineString':
            return geom;
        case 'Polygon':
            return geom.getLinearRing(0);

    }

}

export class CssStyle implements types.IMapStyle {
    map: types.IMapManager;
    css: types.Dict = {};
    oStyle: ol.style.Style = null;
    extras: types.Dict = {};

    static fromSelector(map, selector) {
        let css = findCss(selector);
        if (!css)
            console.warn('selector not found:', selector);
        return new this(map, css || '')
    }

    static fromCss(map, css) {
        return new this(map, css || '')
    }

    constructor(map, css) {
        this.map = map;
        this.css = stripPrefix(typeof css === 'string' ? toDict(css) : css);
        this.oStyle = parse(this.css);
        this.extras = parseExtras(this.css);
    }

    getText(copy) {
        let s = this.oStyle.getText();
        if (s && copy) {
            let c = s['clone']();
            // clone doesn't support these yet
            each(['BackgroundFill', 'BackgroundStroke', 'Padding', 'Overflow'], p =>
                c['set' + p](s['get' + p]())
            );
            return c;
        }
        return s;
    }

    getImage(copy) {
        let s = this.oStyle.getImage();
        if (s && copy)
            s = s['clone']();
        return s;
    }

    apply(geom, label, resolution) {

        let styles = [];

        let bounds = markBounds(geom);

        if (bounds) {
            let image = this.getImage(true);
            if (image) {
                styles.push(new ol.style.Style({
                    image,
                    geometry: new ol.geom.MultiPoint(bounds.getCoordinates())
                }));
            }
        }

        let inRes = this.extras['label-min-resolution'] <= resolution && resolution <= this.extras['label-max-resolution'];

        if (label && inRes) {
            let text = this.getText(true);
            if (text) {
                text.setText(label);
                let opts = {text};

                if (bounds) {
                    if (this.extras['label-placement'] === 'start')
                        opts['geometry'] = new ol.geom.Point(bounds.getFirstCoordinate());
                    if (this.extras['label-placement'] === 'end')
                        opts['geometry'] = new ol.geom.Point(bounds.getLastCoordinate());
                }
                styles.push(new ol.style.Style(opts));
            }
        }

        styles.push(this.oStyle);
        return styles;
    }

    get props() {
        return {
            'type': 'css',
            'content': this.css
        }
    }

}
