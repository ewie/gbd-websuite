import * as ol from 'openlayers';

import * as types from '../types';
import * as tools from '../tools';
import * as api from '../core/gws-api';

const DEFAULT_TILE_TRANSITION = 700;

export class Layer implements types.IMapLayer {
    type = '';
    uid = '';
    title = '';
    attributes = {};

    props: api.LayerBaseProps;

    parent = null;
    children = [];

    expanded = false;
    visible = false;
    selected = false;
    listed = false;
    editable = false;
    unfolded = false;

    resolutions = [];
    minResolution = 0;
    maxResolution = 1e20;
    extent: ol.Extent;

    attribution = null;
    description = null;

    map = null;

    get oLayer() {
        return null;
    }

    get printItem() {
        return null;
    }

    get inResolution() {
        let vs = this.map.viewState;
        return this.minResolution <= vs.resolution && vs.resolution <= this.maxResolution;
    }

    get shouldDraw() {
        return this.visible && this.inResolution;
    }

    get shouldList() {
        if (!this.listed)
            return false;
        if (this.hasChildren)
            return this.children.some(la => la.shouldList);
        return this.inResolution;
    }

    get hasChildren() {
        return this.children.length > 0;
    }

    get isSystem() {
        return String(this.uid)[0] === '_';
    }

    constructor(map: types.IMapManager, props: api.LayerProps) {
        this.map = map;
        this.props = props;

        this.type = this.props.type;
        this.title = this.props.title;
        this.uid = this.props.uid;
        this.attribution = this.props.meta ? this.props.meta.attribution : '';
        this.description = this.props.description || '';
        this.editable = !!this.props.editable;

        this.resolutions = props.resolutions || this.map.resolutions;
        this.extent = props.extent || this.map.extent;

        this.minResolution = Math.min(...this.resolutions);
        this.maxResolution = Math.max(...this.resolutions);

        let defaultOpts = {
            expanded: false,
            visible: true,
            selected: false,
            listed: true,
            unfolded: false
        };
        let opts = Object.assign(defaultOpts, props.options || {});

        this.expanded = opts['expanded'];
        this.visible = opts['visible'];
        this.selected = opts['selected'];
        this.listed = opts['listed'];
        this.unfolded = opts['unfolded'];

    }

    hide() {
    }

    show() {
    }

    changed() {
    }

    beforeDraw() {

    }

    reset() {

    }
}

abstract class OlBackedLayer<T extends ol.layer.Layer> extends Layer {
    _oLayer: T;

    abstract createOLayer(): T;

    get printItem(): api.PrintItem {
        return {
            layerUid: this.uid,
        }
    }

    get oLayer(): T {
        if (!this._oLayer) {
            let la = this.createOLayer();
            la.setVisible(true);
            la.setOpacity(this.props.opacity || 1);
            la.on('change', () => {
                this.map.changed()
            });
            this._oLayer = la;
        }
        return this._oLayer;

    }

    reset() {
        this._oLayer = null;
    }

    hide() {
        this.oLayer.setVisible(false);
    }

    show() {
        this.oLayer.setVisible(true);
    }

    changed() {
        if (this.oLayer)
            this.oLayer.changed();
    }

}

export class BoxLayer extends OlBackedLayer<ol.layer.Image> {
    props: api.BoxLayerProps;

    async loadImage(oImage: ol.Image, url: string) {

        let img: any = oImage.getImage();
        let app = this.map.app;

        img.onload = function () {
            app.whenRequestEnded(url)
        };
        img.onerror = function () {
            app.whenRequestEnded(url)
            console.log('ERROR LOADING', url);
        };

        app.whenRequestStarted(url)
        img.src = url;
    }

    createOLayer() {
        return new ol.layer.Image({
            extent: this.extent,
            source: new ol.source.ImageWMS({
                url: this.props.url,
                ratio: 1,
                imageLoadFunction: (img, url) => this.loadImage(img, url),
                projection: this.map.projection,
                params: {
                    layers: ''
                },
            })
        });
    }
}

export class TileLayer extends OlBackedLayer<ol.layer.Image> {
    props: api.TileLayerProps;

    createOLayer() {
        return new ol.layer.Tile({
            source: new ol.source.TileImage({
                url: this.props.url,
                projection: this.map.projection,
                //transition: DEFAULT_TILE_TRANSITION,
                tileGrid: new ol.tilegrid.TileGrid({
                    extent: this.extent,
                    tileSize: this.props.tileSize,
                    resolutions: this.resolutions,
                })
            })
        });
    }
}

export class OsmLayer extends OlBackedLayer<ol.layer.Image> {
    createOLayer() {
        return new ol.layer.Tile({
            source: new ol.source.OSM({
                url: 'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',

            })
        });
    }
}

export class TreeLayer extends OlBackedLayer<ol.layer.Image> {
    props: api.TreeLayerProps;
    leaves: Array<string> = [];

    get shouldDraw() {
        return this.visibleLeavesUids().length > 0;
    }

    get printItem(): api.PrintItem {
        let ls = this.visibleLeavesUids();

        if (!ls.length)
            return null;

        return {
            layerUid: this.uid,
            subLayers: ls,
        }
    }

    beforeDraw() {
        let ls = this.visibleLeavesUids();

        if (ls.join() !== this.leaves.join()) {
            this.leaves = ls;
            this._oLayer = this.createOLayerWithLeaves(this.leaves);
        }
    }

    createOLayer() {
        return this.createOLayerWithLeaves([]);
    }

    protected createOLayerWithLeaves(leaves) {
        return new ol.layer.Image({
            extent: this.extent,
            opacity: this.props.opacity || 1,
            source: new ol.source.ImageWMS({
                url: this.props.url,
                ratio: 1,
                projection: this.map.projection,
                params: {
                    layers: leaves
                }
            })
        });
    }

    protected visibleLeavesUids() {
        return this.map
            .collect(this, la => la.type === 'leaf' && la.shouldDraw)
            .map(la => la.uid);
    }
}

export class LeafLayer extends Layer {
    props: api.LeafLayerProps;
}

export class RootLayer extends Layer {
    get shouldList() {
        return true;
    }
}

export class GroupLayer extends Layer {
    props: api.GroupLayerProps;
}

abstract class BaseVectorLayer extends OlBackedLayer<ol.layer.Vector> implements types.IMapFeatureLayer {
    props: api.VectorLayerProps;

    style = null;
    editStyle = null;
    features = [];
    geometryType = '';
    dataModel = null;

    get source() {
        return this.oLayer ? this.oLayer.getSource() : null;
    }

    constructor(map, props) {
        super(map, props);
        if (props.style)
            this.style = this.map.getStyle(props.style);
        if (props.editStyle)
            this.editStyle = this.map.getStyle(props.editStyle);
        if (props.geometryType)
            this.geometryType = props.geometryType;
        if (props.dataModel)
            this.dataModel = props.dataModel;
    }

    abstract createSource();

    abstract addFeatures(fs: Array<types.IMapFeature>);

    abstract removeFeature(feature);

    createOLayer() {
        return new ol.layer.Vector({
            source: this.createSource(),
            style: this.map.styleFunction(this.style),
        });
    }

    setStyle(style) {
        this.style = style;
        this.oLayer.setStyle(this.map.styleFunction(this.style));
    }

    clear() {
        this.features = [];
        this.source.clear();
    }

    addFeature(f: types.IMapFeature) {
        return this.addFeatures([f]) === 1;
    }

    async loadFeatures(where) {
        return await [];
    }
}

export class FeatureLayer extends BaseVectorLayer implements types.IMapFeatureLayer {

    get printItem() {
        let fs = tools.compact(this.features.map(f => f.printProps));

        if (fs.length === 0)
            return null;

        return {
            features: fs,
            style: this.style ? this.style.props : null,
            printAsVector: true,
        };
    }

    createSource() {
        return new ol.source.Vector();
    }

    addFeatures(fs) {
        let res = [...this.features];

        let cnt = 0;
        fs.forEach(f => {
            if (f) {
                res.push(f);
                this.source.addFeature(f.oFeature);
                cnt++;
            }
        });
        this.features = res;
        this.map.changed();
        return cnt;
    }

    removeFeature(feature) {
        // if (this.oLayer && feature.oFeature) {
        //     try {
        //         this.oLayer.getSource().removeFeature(feature.oFeature);
        //     } catch (e) {
        //         // can be removed in the meantime.
        //         console.warn(e)
        //     }
        // }
        // console.log('REMOVE', this.oLayer, feature, feature.oFeature)
        //
        //
        this.features = this.features.filter(f => f !== feature);
        this.reset();
    }

    reset() {
        this.source.clear();
        this.features.forEach(f => this.source.addFeature(f.oFeature));
    }

}

export class VectorLayer extends BaseVectorLayer implements types.IMapFeatureLayer {

    get printItem() {
        return {
            layerUid: this.uid,
            style: this.style ? this.style.props : null,
        }
    }

    addFeatures(fs) {
        let res = [];
        let newIds = fs.map(f => f.uid);
        let cnt = 0;

        this.features.forEach(f => {
            if (newIds.indexOf(f.uid) < 0) {
                res.push(f);
            } else {
                this.source.removeFeature(f.oFeature);
            }
        });

        fs.forEach(f => {
            res.push(f);
            this.source.addFeature(f.oFeature);
        });

        this.features = res;
        this.map.changed();
        return cnt;

    }

    async loadFeatures(where) {
        let params = {
            layerUid: this.uid,
            bbox: null
        };
        if (where === 'bbox') {
            params['bbox'] = this.map.bbox;
        }
        let res = await this.map.app.server.mapGetFeatures(params);
        console.log('loadFeatures', this.uid, res.features.length)
        return this.map.readFeatures(res.features);
    }

    reset() {
        this.features = [];
        this.source.clear();
    }

    createSource() {
        return new ol.source.Vector({
            loader: this.loader.bind(this),
            // @TODO: loading strategy must be configurable
            strategy: ol.loadingstrategy.bbox
        });
    }

    removeFeature(feature) {
        if (this.oLayer && feature.oFeature)
            this.oLayer.getSource().removeFeature(feature.oFeature);
    }

    protected async loader(extent, resolution, proj) {
        this.addFeatures(await this.loadFeatures('bbox'));
    }
}
