import * as ol from 'openlayers';
import * as proj4 from 'proj4';

import * as types from '../types';
import * as api from '../core/gws-server.api';
import * as tools from '../tools';

import * as layer from './layer';

let layerTypes = {
    'box': layer.BoxLayer,
    'group': layer.GroupLayer,
    'leaf': layer.LeafLayer,
    'root': layer.RootLayer,
    'tile': layer.TileLayer,
    'tree': layer.TreeLayer,
    'vector': layer.VectorLayer,
    'osm': layer.OsmLayer,
};

import {Feature} from './feature';
import {CssStyle} from './style';
import {DrawInteraction} from './draw';
import {PointerInteraction} from './pointer';
import {ModifyInteraction} from './modify';

const POINTER_DEBOUNCE = 10;
const VIEW_DEBOUNCE = 5;

const ANIMATION_DURATION = 600;
const ANIMATION_EASING = ol.easing.easeOut;

export class MapManager implements types.IMapManager {
    static STOP_WALK = {};

    app: types.IApplication = null;

    crs = '';
    domNode = null;
    oMap: ol.Map = null;
    oView: ol.View = null;
    projection = null;
    root = null;
    resolutions = null;
    extent = null;

    protected connectedToStore = false;
    protected initViewState = null;
    protected updateCount = 0;
    protected intrStack = [];
    protected defaultInteractions = {};
    protected props: api.MapProps;

    // @TODO this should be 'viewExtent' actually
    get bbox() {
        return this.oView.calculateExtent();
    }

    get viewExtent() {
        return this.oView.calculateExtent();
    }

    get size() {
        return this.oMap.getSize();
    }

    get viewState(): types.MapViewState {
        if (this.oView) {
            let v = this.oView,
                c = v.getCenter(),
                res = v.getResolution(),
                rot = v.getRotation();

            return {
                centerX: c[0],
                centerY: c[1],
                resolution: res,
                scale: tools.resolutionToScale(res),
                rotation: rot,
                angle: tools.rad2deg(rot),
            }
        }
    }

    constructor(app, connectedToStore) {
        this.app = app;
        this.connectedToStore = connectedToStore;
    }

    update(args) {
        if (this.connectedToStore)
            this.app.store.update(args);
    }

    async init(props) {
        this.props = props;
        this.domNode = document.querySelector('.gwsMap');

        this.resolutions = this.props.resolutions;
        this.extent = this.props.extent;

        this.initViewState = {
            centerX: this.props.center[0],
            centerY: this.props.center[1],
            resolution: this.props.initResolution,
            rotation: 0
        };

        this.initOMap();
        this.initLayers();
        this.initEvents();
        this.initInteractions();

        this.changed();
        return await true;
    }

    changed() {
        this.update({
            mapUpdateCount: ++this.updateCount,
            mapAttribution: this.visibleAttributions(),
        });
        this.draw();
    }

    //

    addLayer(layer, where, parent) {
        this.insertLayer(layer, where, parent);
        this.changed();
    }

    addTopLayer(layer) {
        this.addLayer(layer, 0, this.root);
    }

    addServiceLayer(layer: types.IMapFeatureLayer) {
        layer.visible = true;
        layer.listed = false;
        this.addTopLayer(layer);
        return layer;
    }

    removeLayer(layer) {
        if (layer && layer.parent)
            layer.parent.children = layer.parent.children.filter(la => la !== layer);
        this.changed();
    }

    getLayer(uid) {
        let found = null;

        this.walk(this.root, la => {
            if (la.uid === uid) {
                found = la;
                return MapManager.STOP_WALK;
            }
        });

        return found;
    }

    setLayerVisible(layer, on) {
        this.walk(layer, la => la.visible = on);
        this.checkGroupVisibility(this.root);
        this.changed();
    }

    setLayerExpanded(layer, on) {
        layer.expanded = on;
        this.changed();
    }

    async selectLayer(layer) {
        this.walk(this.root, la => la.selected = false);
        layer.selected = true;
        this.update({
            'mapSelectedLayer': layer
        });
        this.changed();
    }

    // async queryLayerDescription(layer: types.IMapLayer) {
    //     let res = await this.app.server.mapDescribeLayer({layerUid: layer.uid});
    //     layer.description = res;
    // }

    deselectAllLayers() {
        this.walk(this.root, la => la.selected = false);
        this.update({
            'mapSelectedLayer': null
        });
        this.changed();
    }

    hideAllLayers() {
        this.walk(this.root, la => la.visible = false);
        this.changed();
    }

    setTargetDomNode(node) {
        this.oMap.setTarget(node);
        this.changed();
    }

    //

    protected prepareViewState(vs: any) {
        let p: any = {};

        if ('scale' in vs) {
            vs.resolution = tools.scaleToResolution(vs.scale);
        }

        if ('resolution' in vs) {
            p.resolution = tools.clamp(
                tools.asNumber(vs.resolution),
                Math.min(...this.resolutions),
                Math.max(...this.resolutions),
            );
        }

        if ('center' in vs) {
            vs.centerX = vs.center[0];
            vs.centerY = vs.center[1];
        }

        if ('centerX' in vs && 'centerY' in vs) {
            p.center = this.oView.constrainCenter([
                tools.asNumber(vs.centerX),
                tools.asNumber(vs.centerY)
            ]);
        }

        if ('angle' in vs) {
            vs.rotation = tools.deg2rad(tools.asNumber(vs.angle));
        }

        if ('rotation' in vs) {
            let r = tools.clamp(tools.asNumber(vs.rotation), 0, Math.PI * 2);
            p.rotation = this.oView.constrainRotation(r);
        }

        return p;
    }

    setViewState(vs: any, animate: boolean) {
        let p = this.prepareViewState(vs);
        this.oView.cancelAnimations();

        // console.log('SET_VIEW_STATE 1=', vs)
        // console.log('SET_VIEW_STATE 2=', p)

        if (animate) {
            return this.oView.animate({
                ...p,
                duration: ANIMATION_DURATION,
                easing: ANIMATION_EASING
            }, () => this.updateViewState());
        }

        if ('center' in p)
            this.oView.setCenter(p.center);
        if ('resolution' in p)
            this.oView.setResolution(p.resolution);
        if ('rotation' in p)
            this.oView.setRotation(p.rotation);
    }

    setResolution(n, animate) {
        this.setViewState({resolution: n}, animate);
    }

    setScale(n, animate) {
        this.setViewState({scale: n}, animate);
    }

    setNextResolution(delta, animate) {
        let cur = this.viewState.resolution,
            res = (delta > 0)
                ? Math.min(...this.resolutions.filter(r => r > cur))
                : Math.max(...this.resolutions.filter(r => r < cur));

        if (Number.isFinite(res) && res !== cur)
            this.setResolution(res, animate);
    }

    setRotation(n, animate) {
        this.setViewState({rotation: n}, animate);
    }

    setAngle(n, animate) {
        this.setViewState({angle: n}, animate);
    }

    setCenter(c, animate) {
        this.setViewState({center: c}, animate);
    }

    setViewExtent(extent, animate) {
        if (!extent)
            return;

        let opts = {};

        if (animate) {
            opts = {
                duration: ANIMATION_DURATION,
                easing: ANIMATION_EASING,
                callback: () => this.updateViewState(),
            }
        }

        this.oView.fit(extent, opts);
    }

    resetViewState(animate) {
        this.setViewState(this.initViewState, animate);
    }

    //

    setInteractions(intrs) {
        this.oMap.getInteractions().forEach(intr => intr.setActive(false));
        this.oMap.getInteractions().clear();
        intrs.forEach(intr => {
            if (typeof(intr) === 'string')
                intr = this.defaultInteractions[intr];
            this.oMap.addInteraction(intr)
        });
        this.oMap.getInteractions().forEach(intr => intr.setActive(true));
    }

    pushInteractions() {
        let intrs = [];
        this.oMap.getInteractions().forEach(intr => {
            intr.setActive(false);
            intrs.push(intr);
        });
        this.intrStack.push(intrs);
    }

    popInteractions() {
        if (this.intrStack.length) {
            this.setInteractions(this.intrStack.pop());
        }
    }

    drawInteraction(opts) {
        return new DrawInteraction(this, opts);
    }

    modifyInteraction(opts) {
        return new ModifyInteraction(this, opts);
    }

    pointerInteraction(opts) {
        return new PointerInteraction(this, opts);
    }

    //

    protected initOMap() {
        let vs = this.oView ? this.viewState : this.initViewState;

        this.crs = this.props.crs;

        if (this.crs === 'EPSG:3857') {
            this.projection = ol.proj.get(this.crs);
        } else {
            proj4.defs(this.crs, this.props.crsDef);
            this.projection = ol.proj.get(this.crs);
        }

        if (this.oMap) {
            this.oMap.setLayerGroup(new ol.layer.Group());
            this.oMap = this.oView = null;
        }

        this.oMap = new ol.Map({
            view: new ol.View({
                center: [vs.centerX, vs.centerY],
                resolution: vs.resolution,
                rotation: vs.rotation,
                resolutions: this.resolutions,
                extent: this.extent,
                projection: this.projection,
            }),
            // @TODO: need to pass window.devicePixelRatio around
            pixelRatio: 1,
            controls: [],
            interactions: [],

        });

        this.oView = this.oMap.getView();
    }

    protected initLayers() {

        this.root = this.initLayer({
            type: 'root',
            uid: '_root',
            title: this.props.title,
            editable: false,
            meta: null,

            layers: this.props.layers,

            options: {
                expanded: true,
                visible: true,
                selected: false,
                listed: true,
            },
        });

        this.checkGroupVisibility(this.root);
    }

    protected initLayer(props: api.LayerProps, parent = null): types.IMapLayer {
        let cls = layerTypes[props.type];
        if (!cls)
            throw new Error('unknown layer type: ' + props.type);

        let layer = new cls(this, props);

        if (props['layers']) {
            props['layers'].forEach(p => {
                // propagate group visibility down...
                if (!props.options.visible)
                    p.options.visible = false;
                this.initLayer(p, layer)
            });
        }

        if (parent)
            this.insertLayer(layer, -1, parent);

        return layer;
    }

    updateViewState() {
        let vs = this.viewState;
        this.update({
            mapUpdateCount: ++this.updateCount,

            mapCenterX: vs.centerX,
            mapCenterY: vs.centerY,
            mapResolution: vs.resolution,
            mapRotation: vs.rotation,

            mapEditScale: vs.scale,
            mapEditResolution: vs.resolution,
            mapEditRotation: vs.rotation,
            mapEditAngle: vs.angle,
            mapEditCenterX: vs.centerX,
            mapEditCenterY: vs.centerY,
        });
    }

    updatePointerPosition(cc) {
        this.update({
            mapPointerX: cc[0] | 0,
            mapPointerY: cc[1] | 0,
        });
    }

    updateTimer;

    protected initEvents() {

        let vs = this.viewState;

        this.updatePointerPosition([vs.centerX, vs.centerY]);
        this.updateViewState();

        this.oMap.on('pointermove', tools.debounce(
            e => this.updatePointerPosition(e.coordinate),
            POINTER_DEBOUNCE));

        // @TODO throttle updates
        //
        // let handler = tools.debounce(() => {
        //     if(this.oView.getAnimating())
        //         return;
        //
        //
        //     updateVs();
        //     this.changed();
        // }, VIEW_DEBOUNCE);
        //
        // let update = () => {
        //     if (this.oView.getAnimating()) {
        //         this.updateTimer = setTimeout(update, VIEW_DEBOUNCE);
        //     } else {
        //         updateVs();
        //         this.changed();
        //     }
        //
        // }

        // clearTimeout(this.updateTimer);
        // this.updateTimer = setTimeout(update, VIEW_DEBOUNCE);

        let handler = () => {
            this.updateViewState();
            this.changed();
        };

        this.oView.on('change:resolution', handler);
        this.oView.on('change:center', handler);
        this.oView.on('change:rotation', handler);
    }

    protected initInteractions() {
        this.defaultInteractions = {
            'DragPan': new ol.interaction.DragPan({
                kinetic: new ol.Kinetic(-0.01, 0.1, 100)

            }),
            'PinchZoom': new ol.interaction.PinchZoom({
                constrainResolution: true
            }),
            'MouseWheelZoom': new ol.interaction.MouseWheelZoom({
                constrainResolution: true
            }),
            'ZoomBox': new ol.interaction.DragZoom({
                condition: ol.events.condition.shiftKeyOnly,
                className: 'modZoomBox',
            })
        }
    }

    //

    readFeature(props) {
        return new Feature(this, {props});
    }

    readFeatures(fs) {
        return fs.map(props => new Feature(this, {props}));
    }

    writeFeatures(fs) {
        return fs.map(f => f.props);
    }

    //

    getStyleFromSelector(selector) {
        // @TODO cache
        let s = CssStyle.fromSelector(this, selector);
        if (s)
            return s;
        console.warn('selector not found: ' + selector);
        return null;
    }

    getStyle(p) {
        if (p instanceof CssStyle)
            return p;
        if (p.type === 'css')
            return CssStyle.fromCss(this, p.content);
        if (p.type === 'cssSelector')
            return CssStyle.fromSelector(this, p.value);
        console.warn('unknown style type', p);
    }

    // to be used in 'style: function(f,r)' callbacks
    styleFunction(style?: types.IMapStyle) {
        if (!style)
            return null;
        return function (oFeature, r) {
            return style.apply(oFeature.getGeometry(), oFeature.get('label'), r);
        }
    }

    //

    geom2shape(geom) {
        if (!geom)
            return null;

        // NB: this is our geojson extension
        // the server is supposed to deal with this in a reasonable way
        if (geom instanceof ol.geom.Circle) {
            return {
                crs: this.crs,
                geometry: {
                    type: 'Circle',
                    center: (geom as ol.geom.Circle).getCenter(),
                    radius: (geom as ol.geom.Circle).getRadius(),
                }
            }
        }

        let format = new ol.format.GeoJSON({
            defaultDataProjection: this.projection,
            featureProjection: this.projection,
        });
        return {
            crs: this.crs,
            // @TODO: silly
            geometry: JSON.parse(format.writeGeometry(geom))
        }
    }

    shape2geom(shape) {
        if (!shape || !shape.geometry)
            return null;

        // @TODO: shapes are assumed to be in the map projection

        if (shape.type === 'Circle') {
            return new ol.geom.Circle(
                shape.geometry.center,
                shape.geometry.radius,
            );
        }

        let format = new ol.format.GeoJSON();
        return format.readGeometry(shape.geometry);
    }

    //

    async searchParams(keyword, geometry) {
        // this is async to be like "printParams"
        let ls = this.searchLayers();
        return await {
            bbox: this.bbox,
            keyword,
            layerUids: tools.compact(ls.map(la => la.uid)),
            projectUid: this.app.project.uid,
            resolution: this.viewState.resolution,
            shape: geometry ? this.geom2shape(geometry) : null,
        }
    }

    protected searchLayers() {
        // select visible terminal layers, starting with selected layers, if any
        // otherwise with the root
        let roots = this.collect(this.root, la => la.selected);
        if (!roots.length)
            roots = [this.root];

        let ls = [];

        //roots.forEach(r => ls = ls.concat(this.collect(r, la => la.shouldDraw && !la.hasChildren)));
        roots.forEach(r => ls = ls.concat(this.collect(r, (la: types.IMapLayer) => la.shouldDraw && !la.isSystem)));
        return ls;
    }

    async printParams(boxRect, template, quality) {
        let items = [],
            tempHidden = [],
            dpi = (template.qualityLevels[quality] || {}).dpi;

        let useBitmaps = boxRect && !dpi;

        this.walk(this.root, layer => {
            let pi = layer.shouldDraw && layer.printItem;
            if (!pi)
                return;
            if (useBitmaps) {
                if (!pi.printAsVector)
                    return;
                tempHidden.push(layer);
                layer.hide();
            }
            items.push(pi);
        });

        let vs = this.viewState,
            canvas = this.oMap.getViewport().firstChild as HTMLCanvasElement,
            bbox = null,
            bitmap = null;

        if (boxRect) {
            let rc = canvas.getBoundingClientRect(),
                rb = boxRect,
                cx = rb.left - rc.left,
                cy = rb.top - rc.top,
                coord = this.oMap.getCoordinateFromPixel([cx, cy]);

            if (useBitmaps) {

                let getPixels = () => {

                    let ctx = canvas.getContext('2d'),
                        data = ctx.getImageData(cx, cy, rb.width, rb.height);

                    let cnv2 = document.createElement('canvas');

                    cnv2.width = rb.width;
                    cnv2.height = rb.height;

                    cnv2.getContext('2d').putImageData(data, 0, 0);
                    // @TODO try toBlob to reduce size
                    return cnv2.toDataURL();
                };

                console.time('creating_bitmap');
                // @TODO redraw callback
                bitmap = await tools.delay(200, getPixels)
                console.timeEnd('creating_bitmap');
            }

            tempHidden.forEach(layer => layer.show());

            bbox = [
                coord[0],
                coord[1] - rb.height * vs.resolution,
                coord[0] + rb.width * vs.resolution,
                coord[1],
            ];
        }

        if (bitmap)
            items.push({
                bitmap,
            });

        return {
            format: 'pdf',
            items,
            sections: [],
            projectUid: this.app.project.uid,
            rotation: Math.round(tools.rad2deg(vs.rotation)),
            quality,
            scale: tools.resolutionToScale(vs.resolution),
            templateUid: template.uid,
        }
    }

    //

    protected visibleAttributions() {
        let a = [this.app.project.meta.attribution];

        this.walk(this.root, (layer: types.IMapLayer) => {
            if (layer.shouldDraw)
                a.push(layer.attribution);
        });

        return tools.uniq(tools.compact(a));
    }

    protected checkGroupVisibility(layer) {
        // a group is only visible if some of its children are
        if (layer.hasChildren) {
            layer.children.forEach(la => this.checkGroupVisibility(la));
            layer.visible = layer.children.some(la => la.visible);
        }
    }

    protected insertLayer(layer, where, parent) {
        if (parent) {
            layer.parent = parent;
            if (where < 0)
                parent.children.push(layer);
            else
                parent.children.splice(where, 0, layer);
        } else {
            layer.parent = null;
        }
    }

    draw = tools.debounce(() => this.realDraw(), 500);

    protected realDraw() {
        console.log('REAL_DRAW')
        this.walk(this.root, la => la.beforeDraw());
        let layers = this.collect(this.root, layer => layer.shouldDraw && layer.oLayer);
        this.oMap.setLayerGroup(new ol.layer.Group({
            layers: layers.map(la => la.oLayer).reverse()
        }));
    }

    protected walk(layer, fn) {
        if (fn(layer) === MapManager.STOP_WALK)
            return;
        layer.children.forEach(la => this.walk(la, fn));
    }

    protected collect(layer, fn) {
        let ls = [];

        let walk = layer => {
            let r = fn(layer);
            if (r === MapManager.STOP_WALK)
                return;
            if (r)
                ls.push(layer);
            layer.children.forEach(walk);
        };

        walk(layer);
        return ls;
    }

}